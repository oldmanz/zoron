# -*- mode: org -*-
#+STARTUP: showall
#+TITLE: Zoron 300 Klipper Config
#+PROPERTY: header-args :tangle printer.cfg

* General Reference
Section outlining tasks not related to configuration.
** Building and Flashing Klipper Firmware
  cd /home/pi/klipper
  make menuconfig

  - STM32
  - STM32F446
  - No Bootloader
  - 12mz Crystal
  - USB PA11/PA12

  make

  boot in dfu  (power off board, turn on dfu, power on)

  dfu-util -R -a 0 -s 0x08000000:leave -D out/firmware.bin

  turn off dfu

** Slicer Settings
*** Cura
    PRINT_START BED_TEMP={material_bed_temperature_layer_0} EXTRUDER_TEMP={material_print_temperature_layer_0} CHAMBER_TEMP={build_volume_temperature}  LAYER_HEIGHT=0.3

    PRINT_END
    
* Config Header
#+BEGIN_SRC conf
## Voron Design VORON2 300mm Fysetc Spider TMC2209 UART config
## Generated from zoron-config.org
#+END_SRC
* MCU Definition
** Spider Board
#+BEGIN_SRC conf
[mcu]
serial: /dev/serial/by-id/usb-Klipper_stm32f446xx_42001E001850563046363120-if00
restart_method: command
#+END_SRC

** Raspberry Pi
#+BEGIN_SRC conf
[mcu rpi]
serial: /tmp/klipper_host_mcu
#+END_SRC
* Printer Definition and General Config
Printer Kinematics and Speeds
#+BEGIN_SRC conf
[printer]
kinematics: corexy
max_velocity: 500
max_accel: 9000
max_accel_to_decel: 4000
max_z_velocity: 50
max_z_accel: 500
square_corner_velocity: 5.0


[exclude_object]

[save_variables]
filename: /home/pi/klipper_config/.variables.stb

[virtual_sdcard]
path: ~/gcode_files

#+END_SRC

* Stepper Motors and Heaters
** Steppers X/Y
*** Stepper X - MCU - X-MOT - B Stepper - Left
#+BEGIN_SRC conf
[stepper_x]
step_pin: PE11
dir_pin: !PE10
enable_pin: !PE9
full_steps_per_rotation: 400
microsteps: 32
rotation_distance: 40
endstop_pin: ^PA1
position_min: 0
position_endstop: 300
position_max: 300
homing_speed: 100
homing_retract_dist: 2
second_homing_speed: 5
homing_positive_dir: true
#+END_SRC
**** Driver - X - TMC 2209
#+BEGIN_SRC conf
[tmc2209 stepper_x]
uart_pin: PE7
interpolate: true
run_current: 1.2
hold_current: 0.8
sense_resistor: 0.110
stealthchop_threshold: 0
driver_TBL: 2
driver_TOFF: 3
driver_HEND: 3
driver_HSTRT: 0
driver_PWM_GRAD: 8
driver_PWM_LIM: 9
#+END_SRC

*** Stepper Y - MCU - Y-MOT - A Stepper - Right
160 steps per mm -> 0.00625 mm per step 

## 0.9 Stepper Motor
full_steps_per_rotation: 400
microsteps: 32

##  1.8 Stepper Motor
full_steps_per_rotation: 200
microsteps: 16

#+BEGIN_SRC conf
[stepper_y]
step_pin: PD8
dir_pin: PB12
enable_pin: !PD9
full_steps_per_rotation: 400
microsteps: 32
rotation_distance: 40
endstop_pin: ^PA2
position_min: 0
position_endstop: 308
position_max: 308
homing_speed: 100
homing_retract_dist: 2
second_homing_speed: 5
homing_positive_dir: true
#+END_SRC

**** Driver - Y - TMC 2209
#+BEGIN_SRC conf
[tmc2209 stepper_y]
uart_pin: PE15
interpolate: true
run_current: 1.2
hold_current: 0.8
sense_resistor: 0.110
stealthchop_threshold: 0
driver_TBL: 2
driver_TOFF: 3
driver_HEND: 3
driver_HSTRT: 0
driver_PWM_GRAD: 8
driver_PWM_LIM: 9

#+END_SRC

*** readme
160 steps per mm -> 0.00625 mm per step 

## 0.9 Stepper Motor
full_steps_per_rotation: 400
microsteps: 32

##  1.8 Stepper Motor
full_steps_per_rotation: 200
microsteps: 16

** Steppers Z
*** MAIN - Stepper Z0 - MCU - Z-MOT - Z0 Stepper - Front Left
#+BEGIN_SRC conf
[stepper_z]
step_pin: PD14
dir_pin: !PD13
enable_pin: !PD15
full_steps_per_rotation: 200
microsteps: 16
gear_ratio: 80:16
rotation_distance: 40
endstop_pin: ^PA0
position_endstop: 0
position_max: 275
position_min: -2
homing_speed: 15.0
second_homing_speed: 3.0
homing_retract_dist: 2.0
#+END_SRC

**** Driver - Z0 - TMC 2209
#+BEGIN_SRC conf
[tmc2209 stepper_z]
uart_pin: PD10
interpolate: true
run_current: 1.2
hold_current: 0.8
sense_resistor: 0.110
stealthchop_threshold: 0
driver_TBL: 0
driver_TOFF: 7
driver_HEND: 2
driver_HSTRT: 0
driver_PWM_GRAD: 8
driver_PWM_LIM: 10
#+END_SRC

*** Stepper Z1 - MCU - E1-MOT - Z1 Stepper - Rear Left
#+BEGIN_SRC conf
[stepper_z1]
step_pin: PE6
dir_pin: PC13
enable_pin: !PE5
full_steps_per_rotation: 200
microsteps: 16
gear_ratio: 80:16
rotation_distance: 40
#+END_SRC

**** Driver - Z1 - TMC 2209
#+BEGIN_SRC conf
[tmc2209 stepper_z1]
uart_pin: PC14
interpolate: true
run_current: 1.2
hold_current: 0.8
sense_resistor: 0.110
stealthchop_threshold: 0
driver_TBL: 0
driver_TOFF: 7
driver_HEND: 2
driver_HSTRT: 0
driver_PWM_GRAD: 8
driver_PWM_LIM: 10
#+END_SRC

*** Stepper Z2 - MCU - E2-MOT - Z2 Stepper - Rear Right
#+BEGIN_SRC conf
[stepper_z2]
step_pin: PE2
dir_pin: !PE4
enable_pin: !PE3
full_steps_per_rotation: 200
microsteps: 16
gear_ratio: 80:16
rotation_distance: 40
#+END_SRC

**** Driver - Z2 - TMC 2209
#+BEGIN_SRC conf
[tmc2209 stepper_z2]
uart_pin: PC15
interpolate: true
run_current: 1.2
hold_current: 0.8
sense_resistor: 0.110
stealthchop_threshold: 0
driver_TBL: 0
driver_TOFF: 7
driver_HEND: 2
driver_HSTRT: 0
driver_PWM_GRAD: 8
driver_PWM_LIM: 10
#+END_SRC

*** Stepper Z3 - MCU - E3-MOT - Z3 Stepper - Front Right
#+BEGIN_SRC conf
[stepper_z3]
step_pin: PD12
dir_pin: PC4
enable_pin: !PE8
full_steps_per_rotation: 200
microsteps: 16
gear_ratio: 80:16
rotation_distance: 40
#+END_SRC

**** Driver - Z3 - TMC 2209
#+BEGIN_SRC conf
[tmc2209 stepper_z3]
uart_pin: PA15
interpolate: true
run_current: 1.2
hold_current: 0.8
sense_resistor: 0.110
stealthchop_threshold: 0
driver_TBL: 0
driver_TOFF: 7
driver_HEND: 2
driver_HSTRT: 0
driver_PWM_GRAD: 8
driver_PWM_LIM: 10
#+END_SRC

*** readme
##  800 steps per mm -> 0.00125 mm per step

##  0.9 Stepper Motor
full_steps_per_rotation: 400
microsteps: 32

##  1.8 Stepper
full_steps_per_rotation: 200
microsteps: 16

** Steppers E
*** Stepper Extruder - MCU - E-MOT - E0 - TH0
#+BEGIN_SRC conf
[extruder]
step_pin: PD5
dir_pin: !PD6
enable_pin: !PD4
rotation_distance: 7.674
microsteps: 16
full_steps_per_rotation: 200
nozzle_diameter: 0.400
filament_diameter: 1.75
heater_pin: PB15
sensor_type: PT1000
sensor_pin: PC0
min_temp: 10
max_temp: 300
max_power: 1.0
min_extrude_temp: 170
control = pid
pid_kp = 23.166
pid_ki = 1.170
pid_kd = 114.671
pressure_advance: 0.05
pressure_advance_smooth_time: 0.040
max_extrude_cross_section: 50 
max_extrude_only_distance: 500
#+END_SRC

**** Driver - E0 - TMC 2209
#+BEGIN_SRC conf
[tmc2209 extruder]
uart_pin: PD7
interpolate: false
run_current: 0.45
hold_current: 0.3
sense_resistor: 0.110
stealthchop_threshold: 0
#+END_SRC

*** Extruder Heater Verfiy
#+BEGIN_SRC conf
[verify_heater extruder]
max_error: 120
check_gain_time: 20
hysteresis: 5
heating_gain: 2
#+END_SRC
*** readme
##################### Standard Values #####################
##  BMG spec of extruder pully
##  rotation_distence: 22.68 BMG 5mm axis
##  rotation_distence: 33.00 BMG 8 mm axis
##  gear ratios of different Extruders
##  gear_ratio: 50:10  Voron V0.1 DD
##  gear_ratio: 50:17  Voron Afterburner Clockworks
##  gear_ratio: 80:20  Voron M4
##  gear_ratio: 7.5:1  Voron Afterburner Galileo
############### Different Clockworks Setups ###############
##  Afterburner: Stepper Motor 0.9 step distance 0.00120 calibrated 0.001196
##  dir_pin: P0.11
##  full_steps_per_rotation: 400
##  microsteps: 16
##  rotation_distance: 7.6544
############################################################
##  Galileo: Stepper Motor 1.8 step distance 0.00138 calibrated 0,001375
##  dir_pin: !P0.11
##  full_steps_per_rotation: 200
##  microsteps: 16
##  rotation_distance: 4.401
############### Different Clockworks Setups ###############
##	Update value below when you perform extruder calibration
##	Higher value means less filament extruded
##	If you ask for 100mm of filament, but in reality it is 98mm:
##	step_distance = 98 / 100 * step_distance_old
############################################################


##  Try to keep pressure_advance below 1.0

##  Default is 0.040, leave stock

** Heater Bed
*** SSR - MCU - TB - Fan0
#+BEGIN_SRC conf
[heater_bed]
heater_pin: PB4
sensor_type: Generic 3950
sensor_pin: PC3
max_power: 0.65
min_temp: 10
max_temp: 130
control: pid
pid_kp: 39.533
pid_ki: 1.030
pid_kd: 379.708
#+END_SRC

*** Bed Heater Verfiy
#+BEGIN_SRC conf
[verify_heater heater_bed]
max_error: 120
check_gain_time: 60
hysteresis: 5
heating_gain: 2
#+END_SRC
* Probe and QGL
** Probe
*** Config
#+BEGIN_SRC conf
[probe]
pin: ^PA3
x_offset: 0
y_offset: 19.75
z_offset: 6.42
speed: 7.5
lift_speed: 30.0
samples: 3
samples_result: median
sample_retract_dist: 0.8
samples_tolerance: 0.01
samples_tolerance_retries: 3
#+END_SRC
*** Mag Probe Macros
#+BEGIN_SRC conf
#####################################################################
#  User Macros
#####################################################################
## Used the same names as in <https://github.com/KevinOConnor/klipper/pull/4328>
## to make the switch easier after the PR is merged
[gcode_macro ATTACH_PROBE]
description: Attaching the MagProbe if not already attached
gcode:
    _MAG_PROBE ACTION=ATTACH
    _MAG_PROBE ACTION=CHECK_ATTACH

[gcode_macro DETACH_PROBE]
description: Dock the MagProbe if not already docked
gcode:
    _MAG_PROBE ACTION=DOCK
    _MAG_PROBE ACTION=CHECK_DOCK

[gcode_macro GET_PROBE_STATUS]
description: Prints the current MagProbe state, valid probe states are UNKNOWN, ATTACHED and DOCKED
gcode:
    _MAG_PROBE ACTION=GET_STATUS RESPOND=1


[gcode_macro SET_PROBE_STATUS]
description: Manually specify MagProbe status, valid probe states are UNKNOWN, ATTACHED and DOCKED
variable_state: 'unknown'
gcode:
    {% if 'STATE' in params|upper and
        (params.STATE|lower == 'unknown' or params.STATE|lower == 'attached' or params.STATE|lower == 'docked') %}
        SET_GCODE_VARIABLE MACRO=SET_PROBE_STATUS VARIABLE=state VALUE='"{params.STATE|lower}"'
        SET_GCODE_VARIABLE MACRO=_MAG_PROBE VARIABLE=state VALUE='"{params.STATE|lower}"'
    {% else %}
        {% set state = params.STATE|default('none') %}
        {action_raise_error("Invalid probe state: %s. Valid probe states are [UNKNOWN, ATTACHED, DOCKED]" % state|upper)}
    {% endif %}

#####################################################################
#  Helper Macros
#####################################################################
# QUERY_PROBE must run direct before _PROBE_ACTION
# that relation is insured by the caller id
[gcode_macro _MAG_PROBE]
description: Helper: Query MagProbe state and request action
variable_state: 'unknown'
variable_id: 0
gcode:
    ##### add RESPOND if specified #####
    {% if 'RESPOND' in params|upper %}
        {% set respond = "RESPOND=" + params.RESPOND %}
    {% else %}
        {% set respond = "" %}
    {% endif %}
    ##### generate an id not equal to 0 #####
    {% if id == 0 %}
        {% set id = 1 %}
    {% else %}
        {% set id = id + 1 %}
    {% endif %}
    ##### end of definition #####
    QUERY_PROBE ID={id}
    _PROBE_ACTION ACTION={params.ACTION} ID={id} {respond}
    SET_GCODE_VARIABLE MACRO=_MAG_PROBE VARIABLE=id VALUE={id}
    M400

[gcode_macro _PROBE_ACTION]
description: Helper: Perform MagProbe action
gcode:
    ##### get params and defaults #####
    {% set default_respond = printer['gcode_macro _USER_VARIABLE'].respond_probe_action|int %}
    {% set respond = params.RESPOND|default(default_respond)|int %}
    {% set action = params.ACTION|lower %}
    {% set id = params.ID|default(0)|int %} ; call id 0 means invalid
    ##### get probe variables #####
    {% set probe_id = printer['gcode_macro QUERY_PROBE'].id|default(0)|int %}
    {% set man_state = printer['gcode_macro SET_PROBE_STATUS'].state|lower %}
    ##### generate state #####
    {% if man_state != 'unknown' %}
        SET_GCODE_VARIABLE MACRO=SET_PROBE_STATUS VARIABLE=state VALUE='"unknown"'
        {% set state = man_state %}
        {% if respond == 1 %}
    {action_respond_info("MagProbe: State was set to %s by SET_PROBE_STATUS"% man_state|upper)}
        {% endif %}
    {% elif id == 0 or id != probe_id %}
        {action_raise_error("MagProbe: Call ID invalid or does not match QUERY_PROBE call ID")}
    {% elif printer.probe.last_query|lower == 'false' %}
        {action_raise_error("MagProbe: Please execute QUERY_PROBE first")}
    {% else %}
        {% if printer.probe.last_query|int == 0 %}
    {% set state = 'attached' %}
        {% else %}
    {% set state = 'docked' %}
        {% endif %}
    {% endif %}
    ##### end of defines #####
    SET_GCODE_VARIABLE MACRO=_MAG_PROBE VARIABLE=state VALUE='"{state}"'
    {% if action == 'attach' %}
        {% if state == 'docked' %}
    {% if respond == 1 %}
        {action_respond_info("MagProbe: Attach Probe")}
    {% endif %}
    _ATTACH_PROBE
        {% else %}
    {% if respond == 1 %}
        {action_respond_info("MagProbe: already attached")}
    {% endif %}
        {% endif %}
    {% elif action == 'dock' %}
        {% if state == 'attached' %}
    {% if respond == 1 %}
        {action_respond_info("MagProbe: Dock Probe")}
    {% endif %}
    _DOCK_PROBE
        {% else %}
    {% if respond == 1 %}
        {action_respond_info("MagProbe: May already be docked. Safety Check")}
    {% endif %}
        {% endif %}
    {% elif action == 'check_dock' %}
        {% if state != 'docked' %}
    {action_raise_error("MagProbe: dock failed!")}
        {% endif %}
    {% elif action == 'check_attach' %}
        {% if state != 'attached' %}
    {action_raise_error("MagProbe: attach failed!")}
        {% endif %}
    {% elif action == 'get_status' %}
        {% if respond == 1 %}
    {action_respond_info("MagProbe Status: %s" % state)}
        {% endif %}
    {% else %}
        {action_raise_error("MagProbe: action not defined")}
    {% endif %}

## used probe: klicky probe
## the probe is mounted at the moving gantry -> therefor no Z move needed
##
## Attach:
## 1) Prepare Dock: X(probe_undock_x) Y(probe_undock_y) -> next to the probe dock
## 2) Dock Probe  : X(probe_dock_x)                     -> dock the probe
## 3) Finisch Dock: Y(probe_dock_y)                     -> move probe out of holder
##
## Dock:
## 1) Prepare UnDock: X(probe_dock_x) Y(probe_dock_y) -> infront of  probe dock
## 2) UnDock Probe  : Y(probe_undock_y)               -> get probe into dock
## 3) Finisch UnDock: X(probe_undock_x)               -> move head next to dock
##
[gcode_macro _ATTACH_PROBE]
description: Helper: Attach MagProbe
gcode:
    ##### Get user defines #####
    {% set dock_pos = printer['gcode_macro _USER_VARIABLE'].probe_dock %}
    {% set undock_pos = printer['gcode_macro _USER_VARIABLE'].probe_undock %}
    {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
    {% set t_speed = printer['gcode_macro _USER_VARIABLE'].probe_travel_speed|float * 60 %}
    {% set d_speed = printer['gcode_macro _USER_VARIABLE'].probe_dock_speed|float * 60 %}
    ##### get toolhead position #####
    {% set act_z = printer.toolhead.position.z|float %}
    ##### end of definitions #####
    SAVE_GCODE_STATE NAME=STATE_ATTACH_PROBE
    G90                                             ; absolute positioning
    {% if act_z < z_hop %}
        G1 Z{z_hop} F900                              ; move head up
    {% endif %}
    G0 X{undock_pos[0]} Y{undock_pos[1]} F{t_speed} ; move next to mag-probe
    G0 X{dock_pos[0]} F{d_speed}                    ; move sidewards to attach probe
    G0 Y{dock_pos[1]} F{d_speed}                    ; move out of holder
    RESTORE_GCODE_STATE NAME=STATE_ATTACH_PROBE

[gcode_macro _DOCK_PROBE]
description: Helper: Dock MagProbe
gcode:
    ##### Get user defines #####
    {% set dock_pos = printer['gcode_macro _USER_VARIABLE'].probe_dock %}
    {% set undock_pos = printer['gcode_macro _USER_VARIABLE'].probe_undock %}
    {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
    {% set t_speed = printer['gcode_macro _USER_VARIABLE'].probe_travel_speed|float * 60 %}
    {% set d_speed = printer['gcode_macro _USER_VARIABLE'].probe_dock_speed|float * 60 %}
    ##### get toolhead position #####
    {% set act_z = printer.toolhead.position.z|float %}
    ##### end of definitions #####
    SAVE_GCODE_STATE NAME=STATE_DOCK_PROBE
    G90                                         ; absolute positioning
    {% if act_z < z_hop %}
        G1 Z{z_hop} F900                          ; move head up
    {% endif %}
    G0 X{dock_pos[0]} Y{dock_pos[1]} F{t_speed} ; move infront of mag-probe
    G0 Y{undock_pos[1]} F{d_speed}              ; move into the holder
    G0 X{undock_pos[0]} F{d_speed}              ; move sidewards to remove probe
    RESTORE_GCODE_STATE NAME=STATE_DOCK_PROBE

#####################################################################
#   Customized standard macros
#####################################################################
#  QUAD_GANTRY_LEVEL can be found in probe_qgl.cfg
#  BED_MESH_CALIBRATE can be found in bed_mesh.cfg
#####################################################################
#
#        !!! Caution !!!
#
# PROBE_CALIBRATE can not dock the Magprobe automaticly, as it
# start's a scripting process we need to stop at the execution
# of the base macro. Use
#  - PROBE_ABORT
#  - PROBE_ACCEPT
# instead of the orignal ABORT and ACCEPT to also dock the probe
#
#####################################################################
#
# If your probe needs a Z move for attach/detach use either
#   G0 .... FORCE
#   G1 .... FORCE
#
#####################################################################
[gcode_macro G0]
description: Move gcode that prevents moves lower than the limit when probe attached
rename_existing: G0.1
gcode:
    #####  get hardware enables  #####
    {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
    ##### MagProbe state #####
    {% set probe_state = printer['gcode_macro _MAG_PROBE'].state|default('unknown')|lower %}
    ##### set manual override #####
    {% if 'FORCE' in params|upper or ena_mag_probe == 'false' %}
        {% set force = 1 %}
    {% else %}
        {% set force = 0 %}
    {% endif %}
    ##### get params #####
    {% set get_params = [] %}
    {% for key in params %}
        {% if key is not in ['G', 'FORCE'] %} ;G1/G0 is also seen as paramter
    {% set get_params = get_params.append(key + "=" + params[key])  %}
        {% endif %}
    {% endfor %}
    ##### add caller #####
    {% set tmp = get_params.append("CALLER=G0") %} ;hack to append list objects outside of a loop
    ##### add force #####
    {% set tmp = get_params.append("FORCE=" + force|string) %} ;hack to append list objects outside of a loop
    ##### end of definition #####
    {% if probe_state == 'unknown' and force == 0 %}
        _MAG_PROBE ACTION=GET_STATUS RESPOND=0
    {% endif %}
    _Z_MOVE_CHECK {get_params|join(" ")}

[gcode_macro G1]
description: Move gcode that prevents moves lower than the limit when probe attached
rename_existing: G1.1
gcode:
    #####  get hardware enables  #####
    {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
    ##### MagProbe state #####
    {% set probe_state = printer['gcode_macro _MAG_PROBE'].state|default('unknown')|lower %}
    ##### set manual override #####
    {% if 'FORCE' in params|upper or ena_mag_probe == 'false' %}
        {% set force = 1 %}
    {% else %}
        {% set force = 0 %}
    {% endif %}
    ##### get params #####
    {% set get_params = [] %}
    {% for key in params %}
        {% if key is not in ['G', 'FORCE'] %} ;G1/G0 is also seen as paramter
    {% set get_params = get_params.append(key + "=" + params[key])  %}
        {% endif %}
    {% endfor %}
    ##### add caller #####
    {% set tmp = get_params.append("CALLER=G1") %} ;hack to append list objects outside of a loop
    ##### add force #####
    {% set tmp = get_params.append("FORCE=" + force|string) %} ;hack to append list objects outside of a loop
    ##### end of definition #####
    {% if probe_state == 'unknown' and force == 0 %}
        _MAG_PROBE ACTION=GET_STATUS RESPOND=0
    {% endif %}
    _Z_MOVE_CHECK {get_params|join(" ")}

[gcode_macro _Z_MOVE_CHECK]
description: Helper: Check limit and performe move
gcode:
    ##### define defaults ######
    {% set caller = params.CALLER|default('G0')|upper %}
    {% set force = params.FORCE|default(0)|int %}
    ##### z values #####
    {% set z_min = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
    {% set z_act = printer.toolhead.position.z|float %}
    ##### MagProbe state #####
    {% set probe_state = printer['gcode_macro _MAG_PROBE'].state|default('unknown')|lower %}
    ##### get params and prepare to send them to the base macro #####
    {% set get_params = [] %}
    {% for key in params %}
        {% if key is not in ['Z', 'CALLER', 'FORCE'] %}
    {% set get_params = get_params.append(key + params[key]) %}
        {% elif key is in ['Z'] %}
    {% if force == 1 %} ;manual override of probe check
        {% set get_params = get_params.append(key + params[key]) %}
    {% elif probe_state ==  'unknown' %}
        {action_raise_error("%s: MagProbe state %s run \"_MAG_PROBE ACTION=GET_STATUS\"" % (caller, probe_state|upper))}
    {% elif probe_state ==  'docked' %}
        {% set get_params = get_params.append(key + params[key]) %}
    {% elif probe_state ==  'attached' %}
        ##### define move target position depending on absolute_coordinates #####
        {% if printer.gcode_move.absolute_coordinates|lower == 'true' %}
        {% set z_target = params.Z|float %}
        {% else %}
        {% set z_target = z_act + params.Z|float %}
        {% endif %}
        ##### decide if a Z move can be executed #####
        {% if z_target > z_min or z_act < z_target %}
        {% set get_params = get_params.append(key + params[key]) %}
        {% else %}
        {action_respond_info("%s: Z Moves lower than %.1fmm not allowed with installed probe" % (caller,z_min))}
        {% endif %}
    {% else %}
        {action_raise_error("%s: MagProbe state %s not valid" % (caller, probe_state|upper))}
    {% endif %}
        {% endif %}
    {% endfor %}
    ##### end of definitions #####
    {caller}.1 {get_params|join(" ")}

[gcode_macro QUERY_PROBE]
description: Return the status of the z-probe and store ID
rename_existing: QUERY_PROBE_BASE
variable_id: 0
gcode:
    {% set id = params.ID|default(0) %} ; call id 0 menas invalid
    QUERY_PROBE_BASE
    SET_GCODE_VARIABLE MACRO=QUERY_PROBE VARIABLE=id VALUE={id}

[gcode_macro PROBE_ACCURACY]
description: Probe Z-height accuracy at current XY position and dock/undock MagProbe
rename_existing: PROBE_ACCURACY_BASE
gcode:
    #####  get new parameter. #####
    {% set dock = params.DOCK|default(1)|int %} ; use DOCK=0 to omit the probe docking
    #####  get hardware enables  #####
    {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
    ##### get user defines  #####
    {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
    {% set t_speed = printer['gcode_macro _USER_VARIABLE'].probe_travel_speed|float * 60 %}
    ##### get toolhead parameters #####
    {% set act_z = printer.gcode_move.gcode_position.z|float %}
    {% set absolute_coordinates = printer.gcode_move.absolute_coordinates|lower %}
    ##### get params and prepare to send them to the base macro #####
    {% set get_params = [] %}
    {% for key in params %}
        {% set get_params = get_params.append(key + "=" + params[key])  %}
    {% endfor %}
    ##### end of definitions #####
    # as we need to return to the position with the probe we need to be at least at z_hop
    G90 ; absolute positioning
    {% if ena_mag_probe == 'true' and act_z < z_hop %}
        {action_respond_info("PROBE_ACCURACY: High must be above %.2f" % z_hop)}
        G1 Z{z_hop} F900 ; move head up
    {% endif %}
    M400 ; get the buffer cleard first
    SAVE_GCODE_STATE NAME=STATE_PROBE_ACCURACY
    {% if ena_mag_probe == 'true' %}
        ATTACH_PROBE
        RESTORE_GCODE_STATE NAME=STATE_PROBE_ACCURACY MOVE=1 MOVE_SPEED={t_speed}
    {% endif %}
    PROBE_ACCURACY_BASE {get_params|join(" ")}
    {% if ena_mag_probe == 'true' and dock == 1 %}
        DETACH_PROBE
        RESTORE_GCODE_STATE NAME=STATE_PROBE_ACCURACY MOVE=1 MOVE_SPEED={t_speed}
    {% endif %}
    {% if absolute_coordinates == 'false' %} G91 {% endif %}

[gcode_macro PROBE]
description: Probe Z-height at current XY position and dock/undock MagProbe
rename_existing: PROBE_BASE
gcode:
    #####  get new parameter. #####
    {% set dock = params.DOCK|default(1)|int %} ; use DOCK=0 to omit the probe docking
    #####  get hardware enables  #####
    {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
    ##### get user defines  #####
    {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
    {% set t_speed = printer['gcode_macro _USER_VARIABLE'].probe_travel_speed|float * 60 %}
    ##### get toolhead parameters #####
    {% set act_z = printer.gcode_move.gcode_position.z|float %}
    {% set absolute_coordinates = printer.gcode_move.absolute_coordinates|lower %}
    ##### get params and prepare to send them to the base macro #####
    {% set get_params = [] %}
    {% for key in params %}
        {% set get_params = get_params.append(key + "=" + params[key])  %}
    {% endfor %}
    ##### end of definitions #####
    # as we need to return to the position with the probe we need to be at least at z_hop
    G90 ; absolute positioning
    {% if ena_mag_probe == 'true' and act_z < z_hop %}
        {action_respond_info("PROBE: High must be above %.2f" % z_hop)}
        G1 Z{z_hop} F900 ; move head up
    {% endif %}
    M400 ; get the buffer cleard first
    SAVE_GCODE_STATE NAME=STATE_PROBE
    {% if ena_mag_probe == 'true' %}
        ATTACH_PROBE
        RESTORE_GCODE_STATE NAME=STATE_PROBE MOVE=1 MOVE_SPEED={t_speed}
    {% endif %}
    PROBE_BASE {get_params|join(" ")}
    G1 Z{z_min} F900 ; move head up to remove trigger
    {% if ena_mag_probe == 'true' and dock == 1 %}
        DETACH_PROBE
        RESTORE_GCODE_STATE NAME=STATE_PROBE MOVE=1 MOVE_SPEED={t_speed}
    {% endif %}
    {% if absolute_coordinates == 'false' %} G91 {% endif %}

[gcode_macro PROBE_CALIBRATE]
description: Calibrate the probe's z_offset and undock MagProbe
rename_existing: PROBE_CALIBRATE_BASE
gcode:
    #####  get hardware enables  #####
    {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
    ##### get user defines  #####
    {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
    {% set t_speed = printer['gcode_macro _USER_VARIABLE'].probe_travel_speed|float * 60 %}
    ##### get toolhead parameters #####
    {% set act_z = printer.gcode_move.gcode_position.z|float %}
    {% set absolute_coordinates = printer.gcode_move.absolute_coordinates|lower %}
    ##### get params and prepare to send them to the base macro #####
    {% set get_params = [] %}
    {% for key in params %}
        {% set get_params = get_params.append(key + "=" + params[key])  %}
    {% endfor %}
    ##### end of definitions #####
    # as we need to return to the position with the probe we need to be at least at z_hop
    G90 ; absolute positioning
    {% if ena_mag_probe == 'true' and act_z < z_hop %}
        {action_respond_info("PROBE_CALIBRATE: High must be above %.2f" % z_hop)}
        G1 Z{z_hop} F900 ; move head up
    {% endif %}
    M400 ; get the buffer cleard first
    SAVE_GCODE_STATE NAME=STATE_PROBE_CALIBRATE
    {% if ena_mag_probe == 'true' %}
        ATTACH_PROBE
        RESTORE_GCODE_STATE NAME=STATE_PROBE_CALIBRATE MOVE=1 MOVE_SPEED={t_speed}
    {% endif %}
    SET_GCODE_VARIABLE MACRO=PROBE_ABORT VARIABLE=caller VALUE='"calib"'
    SET_GCODE_VARIABLE MACRO=PROBE_ABORT VARIABLE=absolute_coordinates VALUE='"{absolute_coordinates}"'
    PROBE_CALIBRATE_BASE {get_params|join(" ")}

    [gcode_macro PROBE_ABORT]
    description: Abort manual Z probing tool for Probe and dock MagProbe
    variable_caller: 'unknown'
    variable_absolute_coordinates: False
    gcode:
    #####  get hardware enables  #####
    {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
    ##### get user defines  #####
    {% set t_speed = printer['gcode_macro _USER_VARIABLE'].probe_travel_speed|float * 60 %}
    ##### end of definitions #####
    {% if ena_mag_probe == 'true' and caller|lower|string == 'calib' %}
        ABORT
        DETACH_PROBE
        RESTORE_GCODE_STATE NAME=STATE_PROBE_CALIBRATE MOVE=1 MOVE_SPEED={t_speed}
        {% if absolute_coordinates == 'false' %} G91 {% endif %}
    SET_GCODE_VARIABLE MACRO=PROBE_ABORT VARIABLE=caller VALUE='"unknown"'
    {% else %}
        {action_respond_info("PROBE_ABORT: Executed while PROBE_CALIBRATE is not running")}
    {% endif %}

    [gcode_macro PROBE_ACCEPT]
    description: Accept the current Z position for Probe and dock MagProbe
    gcode:
    #####  get variables from ABORT  #####
    {% set caller = printer['gcode_macro PROBE_ABORT'].caller %}
    {% set absolute_coordinates = printer['gcode_macro PROBE_ABORT'].absolute_coordinates %}
    #####  get hardware enables  #####
    {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
    ##### get user defines  #####
    {% set t_speed = printer['gcode_macro _USER_VARIABLE'].probe_travel_speed|float * 60 %}
    ##### end of definitions #####
    {% if ena_mag_probe == 'true' and caller|lower|string == 'calib' %}
        ACCEPT
        DETACH_PROBE
        RESTORE_GCODE_STATE NAME=STATE_PROBE_CALIBRATE MOVE=1 MOVE_SPEED={t_speed}
        {% if absolute_coordinates == 'false' %} G91 {% endif %}
    SET_GCODE_VARIABLE MACRO=PROBE_ABORT VARIABLE=caller VALUE='"unknown"'
    {% else %}
        {action_respond_info("PROBE_ACCEPT: Executed while PROBE_CALIBRATE is not running")}
    {% endif %}
#+END_SRC
*** Z Calibration
#+BEGIN_SRC conf
#####################################################################
# Z Calibration
#####################################################################
[z_calibration]
#   The X and Y coordinates (in mm) for clicking the nozzle on the
#   Z endstop.
probe_nozzle_x: 98
probe_nozzle_y: 308
#   The X and Y coordinates (in mm) for clicking the probe's switch
#   on the Z endstop.
probe_switch_x:88
probe_switch_y: 288
#   The X and Y coordinates (in mm) for probing on the print surface
#   (e.g. the center point) These coordinates will be adapted by the
#   probe's X and Y offsets. The default is the relative_reference_index
#   of the configured bed_mesh. It will raise an error if there is no
#   probe_bed site and no bed_mesh with a relative_reference_index
#   configured.
probe_bed_x: 150
probe_bed_y: 150
#   The trigger point offset of the used mag-probe switch.
#   This needs to be fined out manually.
#   A smaller value is more away from bed
switch_offset: 5.95
#   The maximum allowed deviation of the calculated offset.
#   If the offset exceeds this value, it will stop!
#   The default is 1.0 mm.
max_deviation: 2.75
#   The number of times to probe each point. The probed z-values
#   will be averaged. The default is from the probe's configuration.
#samples: default from "probe:samples" section
#   The maximum Z distance (in mm) that a sample may differ from other
#   samples. The default is from the probe's configuration.
#samples_tolerance: default from "probe:samples_tolerance" section
#   The number of times to retry if a sample is found that exceeds
#   samples_tolerance. The default is from the probe's configuration.
#samples_tolerance_retries: default from "probe:samples_tolerance_retries" section
#   The calculation method when sampling more than once - either
#   "median" or "average". The default is from the probe's configuration.
#samples_result: default from "probe:samples_result" section
#   The distance in mm to move up before moving to the next
#   position. The default is two times the z_offset from the probe's
#   configuration.
clearance: 20
#position_min: default from "stepper_z:position_min" section.
#   The moving speed in X and Y. The default is 50 mm/s.
speed: 300
#   Speed (in mm/s) of the Z axis when lifting the probe between
#   samples and clearance moves. The default is from the probe's
#   configuration.
#lift_speed: default from "probe:lift_speed" section
#   The fast probing speed (in mm/s) used, when probing_first_fast
#   is activated. The default is from the Z rail configuration.
#probing_speed: default from "stepper_z:homing_speed" section.
#   The slower speed (in mm/s) for probing the recorded samples.
#   The default is second_homing_speed of the Z rail configuration.
#probing_second_speed: default from "stepper_z:second_homing_speed" section.
#   Distance to backoff (in mm) before probing the next sample.
#   The default is homing_retract_dist from the Z rail configuration.
#probing_retract_dist: default from "stepper_z:homing_retract_dist" section.
#   If true, the first probing is done faster by the probing speed.
#   This is to get faster down and the result is not recorded as a
#   probing sample. The default is false.
probing_first_fast: true
#   A list of G-Code commands to execute prior to each calibration command.
#   See docs/Command_Templates.md for G-Code format. This can be used to
#   attach the probe.
start_gcode: DETACH_PROBE
#   A list of G-Code commands to execute prior to each probing on the
#   mag-probe. See docs/Command_Templates.md for G-Code format. This can be
#   used to attach the probe after probing on the nozzle and before probing
#   on the mag-probe.
before_switch_gcode: ATTACH_PROBE
#   A list of G-Code commands to execute after each calibration command.
#   See docs/Command_Templates.md for G-Code format. This can be used to
#   detach the probe afterwards.
end_gcode: DETACH_PROBE
  
[gcode_macro CALIBRATE_Z]
description: Automatically calibrates the nozzles offset to the print surface and dock/undock MagProbe 
rename_existing: CALIBRATE_Z_BASE
gcode:
  ##### get user defines  #####
  {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
  #####  get hardware enables  #####
  {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
  ##### get toolhead parameters #####
  {% set act_z = printer.gcode_move.gcode_position.z|float %}
  #### end of definitions #####
  {% if ena_mag_probe == 'true' %}
    {% if act_z < z_hop %}
      G90 ; absolute positioning
      {action_respond_info("CALIBRATE_Z: High must be above %.2f" % z_hop)}
      G1 Z{z_hop} F900 ; move head up
    {% endif %}
    _SET_Z_CURRENT VAL=HOME   ; reduce Z current
    g28 z ; Home Z fix
    CALIBRATE_Z_BASE
    _SET_Z_CURRENT            ; set Z current back to cfg value
  {% endif %}
#+END_SRC
*** Probe Accuracy Testing
##+BEGIN_SRC conf
[gcode_macro TEST_PROBE_ACCURACY]
# Continuously run PROBE_ACCURACY while:
#     - idling for START_IDLE_MINUTES
#     - heating the bed to BED_TEMP
#     - once at BED_TEMP, letting the bed soak for BED_SOAK_MINUTES
#     - with the bed still on, heating the extruder to EXTRUDER_TEMP
#     - once at EXTRUDER_TEMP, letting the extruder soak for EXTRUDER_SOAK_MINUTES
#     - turning off the heaters, and idling for END_IDLE_MINUTES
default_parameter_START_IDLE_MINUTES: 5
default_parameter_END_IDLE_MINUTES: 10
default_parameter_BED_TEMP: 110
default_parameter_EXTRUDER_TEMP: 240
default_parameter_BED_SOAK_MINUTES: 30
default_parameter_EXTRUDER_SOAK_MINUTES: 15
default_parameter_DWELL_SECONDS: 1
default_parameter_DWELL_LIFT_Z: -1
variable_start_idle_minutes: 0
variable_bed_temp: 0
variable_extruder_temp: 0
variable_bed_soak_minutes: 0
variable_extruder_soak_minutes: 0
variable_dwell_seconds: 0
variable_dwell_lift_z: 0
variable_end_idle_minutes: 0
variable_state: 'start'
variable_next_state: 'none'
gcode:
    # Copy parameters into gcode variables.
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=start_idle_minutes VALUE={ START_IDLE_MINUTES|int }
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=bed_temp VALUE={ BED_TEMP|int }
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=extruder_temp VALUE={ EXTRUDER_TEMP|int }
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=bed_soak_minutes VALUE={ BED_SOAK_MINUTES|int }
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=extruder_soak_minutes VALUE={ EXTRUDER_SOAK_MINUTES|int }
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=dwell_seconds VALUE={ DWELL_SECONDS|int }
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=dwell_lift_z VALUE={ DWELL_LIFT_Z|int }
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=end_idle_minutes VALUE={ END_IDLE_MINUTES|int }

    # Initialize state variables in case they have old values from last run.
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=state VALUE='"start"'
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=next_state VALUE='"none"'

    # Schedule main loop.
    UPDATE_DELAYED_GCODE ID=probe_accuracy_loop DURATION=1


[delayed_gcode probe_accuracy_loop]
gcode:
    {% set tmacro = printer['gcode_macro TEST_PROBE_ACCURACY'] %}

    {% if tmacro.state == 'start' %}
        { action_respond_info('TEST_PROBE_ACCURACY: START') }
        SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=state VALUE='"start_idle"'
        SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=next_state VALUE='"start_idle_done"'
        UPDATE_DELAYED_GCODE ID=probe_accuracy_set_next_state DURATION={ tmacro.start_idle_minutes|int * 60 }

    {% elif tmacro.state == 'start_idle_done' %}
        {% if tmacro.bed_temp >= 0 %}
            M140 S{ tmacro.bed_temp }
            { action_respond_info('TEST_PROBE_ACCURACY: BED HEATING TO %s' % tmacro.bed_temp) }
            SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=state VALUE='"bed_heating"'
        {% else %}
            # Skip heating and soaking the bed, go directly to bed_soaked state.
            SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=state VALUE='"bed_soaked"'
        {% endif %}

    {% elif tmacro.state == 'bed_heating' %}
        {% if printer.heater_bed.temperature >= tmacro.bed_temp %}
            { action_respond_info('TEST_PROBE_ACCURACY: BED HEATED TO %s' % tmacro.bed_temp) }
            SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=state VALUE='"bed_soaking"'
            SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=next_state VALUE='"bed_soaked"'
            UPDATE_DELAYED_GCODE ID=probe_accuracy_set_next_state DURATION={ tmacro.bed_soak_minutes|int * 60 }
        {% endif %}

    {% elif tmacro.state == 'bed_soaked' %}
        {% if tmacro.bed_temp >= 0 %}
            { action_respond_info('TEST_PROBE_ACCURACY: BED SOAKED') }
        {% endif %}
        {% if tmacro.extruder_temp >= 0 %}
            M104 S{ tmacro.extruder_temp }
            { action_respond_info('TEST_PROBE_ACCURACY: EXTRUDER HEATING TO %s' % tmacro.extruder_temp) }
            SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=state VALUE='"extruder_heating"'
        {% else %}
            # Skip heating and soaking the extruder, go directly to extruder_soaked state.
            SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=state VALUE='"extruder_soaked"'
        {% endif %}

    {% elif tmacro.state == 'extruder_heating' %}
        {% if printer.extruder.temperature >= tmacro.extruder_temp %}
            { action_respond_info('TEST_PROBE_ACCURACY: EXTRUDER HEATED TO %s' % tmacro.extruder_temp) }
            SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=state VALUE='"extruder_soaking"'
            SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=next_state VALUE='"extruder_soaked"'
            UPDATE_DELAYED_GCODE ID=probe_accuracy_set_next_state DURATION={ tmacro.extruder_soak_minutes|int * 60 }
        {% endif %}

    {% elif tmacro.state == 'extruder_soaked' %}
        {% if tmacro.extruder_temp >= 0 %}
            { action_respond_info('TEST_PROBE_ACCURACY: EXTRUDER SOAKED') }
        {% endif %}
        TURN_OFF_HEATERS
        SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=state VALUE='"end_idle"'
        SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=next_state VALUE='"done"'
        UPDATE_DELAYED_GCODE ID=probe_accuracy_set_next_state DURATION={ tmacro.end_idle_minutes|int * 60 }

    {% elif tmacro.state == 'done' %}
        { action_respond_info('TEST_PROBE_ACCURACY: DONE') }
        G90
        G1 Z30
        UPDATE_DELAYED_GCODE ID=probe_accuracy_loop DURATION=0

    {% endif %}

    {% if tmacro.state != 'done' %}
        M105
        PROBE_ACCURACY
        {% if tmacro.dwell_lift_z >= 0 %}
            G1 Z{ tmacro.dwell_lift_z }
        {% endif %}
        M400
        UPDATE_DELAYED_GCODE ID=probe_accuracy_loop DURATION={ tmacro.dwell_seconds }
    {% endif %}

[delayed_gcode probe_accuracy_set_next_state]
gcode:
    {% set tmacro = printer['gcode_macro TEST_PROBE_ACCURACY'] %}
    SET_GCODE_VARIABLE MACRO=TEST_PROBE_ACCURACY VARIABLE=state VALUE='"{ tmacro.next_state }"'
#+END_SRC
*** readme
############### Different Probe Settings ###############
##  Omron: 
##  speed: 10.0
##  lift_speed: 30.0
##  samples: 9
##  samples_result: median
##  sample_retract_dist: 0.5
##  samples_tolerance: 0.006
##  samples_tolerance_retries: 10
##  y_offset: 25.00
########################################################
##  Super Pinda:
##  speed: 7.5
##  lift_speed: 30.0
##  samples: 6
##  samples_result: median
##  sample_retract_dist: 0.8
##  samples_tolerance: 0.005
##  samples_tolerance_retries: 10
##  y_offset: 25.00
########################################################
##  MagProbe Klicky
##  speed: 7.5
##  lift_speed: 30.0
##  sample: 4
##  samples_result: median
##  sample_retract_dist: 0.8
##  samples_tolerance: 0.005
##  samples_tolerance_retries: 10
##  y_offset: 19.75
##  z_offset: 6.42 ;not needed since a Endstop is used
############### Different Probe Settings ##############
** QGL
#+BEGIN_SRC conf
[quad_gantry_level]
gantry_corners:
    -60,-10
    360,370
points:
    50,25
    50,225
    250,225
    250,25

speed:                  200
horizontal_move_z:      20
retries:                20
retry_tolerance:        0.0075
max_adjust:             15
#+END_SRC

*** Macro
**** Quad Gantry Level
#+BEGIN_SRC conf
[gcode_macro QUAD_GANTRY_LEVEL]
description: Conform a moving, twistable gantry to the shape of a stationary bed
rename_existing: QUAD_GANTRY_LEVEL_BASE
gcode:
    #####  get user defines  #####
    {% set park_pos = printer['gcode_macro _USER_VARIABLE'].park_bed %}
    {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
    #####  get hardware enables  #####
    {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
    ##### get toolhead position #####
    {% set act_z = printer.toolhead.position.z|float %}
    #####  set default  #####
    {% set park = params.PARK|default('true') %}
    #####  end of definitions  #####
    SAVE_GCODE_STATE NAME=STATE_QUAD_GANTRY_LEVEL
    _SET_Z_CURRENT VAL=HOME
    {% if "xyz" not in printer.toolhead.homed_axes %}
    G28
    {% endif %}
    {% if ena_mag_probe == 'true' %}
    {% if act_z < z_hop %}
        G1 Z{z_hop} F900 ; move head up to insure Probe is not triggered in error case
    {% endif %}
    ATTACH_PROBE
    {% endif %}
    QUAD_GANTRY_LEVEL_BASE
    {% if ena_mag_probe == 'true' %} DETACH_PROBE {% endif %}
    G28 Z
    _SET_Z_CURRENT
    {% if park|lower == 'true' %}
    G90
    G0 Z{park_pos[2]} F1800           ; move nozzle to z high first
    G0 X{park_pos[0]} Y{park_pos[1]} F18000 ; home to get toolhead in the middle
    {% endif %}
    RESTORE_GCODE_STATE NAME=STATE_QUAD_GANTRY_LEVEL
#+END_SRC
**** Check QGL
#+BEGIN_SRC conf
[gcode_macro CHECK_QGL]
description: Run after QUAD_GANTRY_LEVEL to insure it passes
gcode:
    #####  Get user defines  #####
    {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
    #####  Get hardware enables  #####
    {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
    #####  end of definitions  #####
    # check that after QGL and cancle print in case of failuare
    {% if printer.quad_gantry_level.applied|lower == 'false' %}
    {action_respond_info("QGL CHECK: Fail therefore cancel the print")}
    G90
    G0 Z{z_hop} F900           ; move nozzle to z high first
    {% if ena_mag_probe == 'true' %} DETACH_PROBE {% endif %}
    PAUSE_BASE
    UPDATE_DELAYED_GCODE ID=_EXECUTE_CANCEL_PRINT DURATION=1
    {% else %}
    {action_respond_info("QGL CHECK: Pass")}
    {% endif %}
#+END_SRC

*** readme
##  Probe points are nozzle positions, we need to substract the probe offset

* Homing
** Homing Override
#+BEGIN_SRC jinja2
[homing_override]
axes: z
set_position_z: 0
gcode:
  ##### get user defines #####
  # use -10 as default to insure it error in case the variable is not existing
  {% set z_endstop = printer['gcode_macro _USER_VARIABLE'].z_endstop|default([-10,-10]) %}
  {% set z_endstop_hop = printer['gcode_macro _USER_VARIABLE'].z_endstop_hop %}
  {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop %}
  ##### end of definitions #####
  SAVE_GCODE_STATE NAME=STATE_HOMING
  G91                      ; set relative
  G0 Z{z_endstop_hop} F900 ; lift nozzle
  G90                      ; set absolute
  ## reduce current of Z motors
  _SET_ACC VAL=HOME
  _SET_Z_CURRENT VAL=HOME
  # Home X and Y only for G28 or G28 XYZ
  {% if 'Z' in params|upper %}
    {% if "x" not in printer.toolhead.homed_axes %}
      G28 X
    {% endif %}
    {% if "y" not in printer.toolhead.homed_axes %}
      G28 Y
    {% endif %}
  {% else %}
    G28 X Y
  {% endif %}      
  ##	XY Location of the Z Endstop Switch
  G0 X{z_endstop[0]} Y{z_endstop[1]} F7200 
  # Home Z
  G28 Z
  ## move nozzle from pin
  G0 Z2 F300
  ## return to org current settings
  _SET_Z_CURRENT
  _SET_ACC
  # Lift Z
  G0 Z{z_hop} F1800
  RESTORE_GCODE_STATE NAME=STATE_HOMING
#+END_SRC

** Conditional Homing
#+BEGIN_SRC conf
[gcode_macro _CG28]
description: Helper: Conditional homing
gcode:
  {% if "xyz" not in printer.toolhead.homed_axes %}
    G28
  {% endif %}
#+END_SRC

** Set Z Current
#+BEGIN_SRC conf
[gcode_macro _SET_Z_CURRENT]
description: Helper: Set Z-drive motor current
variable_last_val: 'CONFIG'
gcode:
  ###### set default values #####
  {% set default_respond = printer['gcode_macro _USER_VARIABLE'].respond_set_z_current|int %}
  {% set val = params.VAL|default('CONFIG') %}
  {% set respond = params.RESPOND|default(default_respond)|int %}
  {% if val == 'HOME' %}
    {% set z_run  = printer['gcode_macro _USER_VARIABLE'].z_home_current %}
    {% set z_hold = printer['gcode_macro _USER_VARIABLE'].z_home_current %}
  {% else %}
    {% if 'tmc2209 stepper_z' in printer.configfile.settings %}
      {% set z_run  = printer.configfile.settings['tmc2209 stepper_z'].run_current %}
      {% set z_hold = printer.configfile.settings['tmc2209 stepper_z'].hold_current %}
    {% elif 'tmc5160 stepper_z' in printer.configfile.settings %}
      {% set z_run  = printer.configfile.settings['tmc5160 stepper_z'].run_current %}
      {% set z_hold = printer.configfile.settings['tmc5160 stepper_z'].hold_current %}
    {% endif %}
  {% endif %}
  ##### end of definition #####
  {% if val != last_val %}
    SET_GCODE_VARIABLE MACRO=_SET_Z_CURRENT VARIABLE=last_val VALUE='"{val}"'
    {% if respond == 1 %}
      {action_respond_info("Home&Probe: RunCur %.2fA rms HoldCur %.2fA rms" % (z_run|float, z_hold|float))}
    {% endif %}
    SET_TMC_CURRENT STEPPER=stepper_z  CURRENT={z_run} HOLDCURRENT={z_hold}
    SET_TMC_CURRENT STEPPER=stepper_z1 CURRENT={z_run} HOLDCURRENT={z_hold}
    SET_TMC_CURRENT STEPPER=stepper_z2 CURRENT={z_run} HOLDCURRENT={z_hold}
    SET_TMC_CURRENT STEPPER=stepper_z3 CURRENT={z_run} HOLDCURRENT={z_hold}
    M400
  {% endif %}
#+END_SRC

** Set Acceleration
#+BEGIN_SRC conf
[gcode_macro _SET_ACC]
description: Helper: Set accel and accel_to_decel value
variable_last_val: 'CONFIG'
gcode:
  ##### set default value #####
  {% set default_respond = printer['gcode_macro _USER_VARIABLE'].respond_set_acc|int %}
  {% set val = params.VAL|default('CONFIG') %}
  {% set respond = params.RESPOND|default(default_respond)|int %}
  {% if val == 'HOME' %}
    {% set accel = printer['gcode_macro _USER_VARIABLE'].home_accel %}
    {% set accel_to_decel = printer['gcode_macro _USER_VARIABLE'].home_accel|int / 2 %}
  {% else %}
    {% set accel = printer.configfile.settings.printer.max_accel %}
    {% set accel_to_decel = printer.configfile.settings.printer.max_accel_to_decel %}
  {% endif %}
  ##### end of definition #####
  {% if val != last_val %}
    SET_GCODE_VARIABLE MACRO=_SET_ACC VARIABLE=last_val VALUE='"{val}"'
    {% if respond == 1 %}
      {action_respond_info("VELOCITY_LIMIT set ACCEL: %d ACCEL_TO_DECEL: %d" % (accel|int, accel_to_decel|int))}
    {% endif %}
    SET_VELOCITY_LIMIT ACCEL={accel} ACCEL_TO_DECEL={accel_to_decel}
  {% endif %}
#+END_SRC
* Bed Mesh
#+BEGIN_SRC conf
[bed_mesh]
mesh_min: 40,40
mesh_max: 260,260
speed: 1000
horizontal_move_z: 20
probe_count: 9,9
algorithm: bicubic
relative_reference_index: 40
move_check_distance: 3
split_delta_z: 0.0125
mesh_pps: 2,2
#+END_SRC

** Macros
*** Bed Mesh Calibrate
#+BEGIN_SRC conf
[gcode_macro BED_MESH_CALIBRATE]
description: Perform QGL and bed mesh leveling
rename_existing: BED_MESH_CALIBRATE_BASE
gcode:
  #####  get hardware enables  #####
  {% set ena_mag_probe = printer['gcode_macro _USER_VARIABLE'].mag_probe|lower %}
  ##### get params and prepare to send them to the base macro #####
  {% set get_params = [] %}
  {% for key in params %}
    {% set get_params = get_params.append(key + "=" + params[key])  %}
  {% endfor %}
  ##### end of definitions #####
  _CG28
  BED_MESH_CLEAR
  ## check if QGL was already executed
  {% if printer.quad_gantry_level.applied|lower == 'false' %}
    QUAD_GANTRY_LEVEL PARK=false
  {% endif %}
  {% if ena_mag_probe == 'true' %} ATTACH_PROBE {% endif %}
  BED_MESH_CALIBRATE_BASE {get_params|join(" ")}
  {% if ena_mag_probe == 'true' %} DETACH_PROBE {% endif %}
#+END_SRC

*** BED Mesh Store
#+BEGIN_SRC conf
[gcode_macro BED_MESH_STORE]
description: Generate a mesh, name it and run save_config if requested
variable_save_at_end: 'false' 
gcode:
  ##### set default parameter value #####
  {% set save = params.SAVE|default('true') %}
  {% set park = params.PARK|default('true') %}
  #############  Get user defines  #############
  {% set center_x = printer["gcode_macro _USER_VARIABLE"].center_x %}
  {% set center_y = printer["gcode_macro _USER_VARIABLE"].center_y %}
  {% set z_min_delta = printer["gcode_macro _USER_VARIABLE"].z_min_delta %}
  {% set z_hop = printer["gcode_macro _USER_VARIABLE"].z_hop %}
  {% set bed_temp = printer.heater_bed.target|int %}
  ##### define plate name: Voron (default) or flexplate name #####
  {% set plate_name = 'Voron' %}
  {% if 'save_variables' in printer.configfile.config %}
    {% if printer.save_variables.variables.plate_array is defined %}
      {% set plate_index = printer.save_variables.variables.plate_index|int %}
      {% set plate_name = printer.save_variables.variables.plate_array[plate_index][0] %}
    {% endif %}
  {% endif %}
  ##### join everything to a single mesh name #####
  {% set mesh_name = plate_name + "-Bed_Temp-" + bed_temp|string + "C" %}
  ##### end of definitions #####
  BED_MESH_CALIBRATE
  BED_MESH_PROFILE SAVE={mesh_name}
  BED_MESH_PROFILE REMOVE=default
  {% if park|lower == 'true' %}
    G90                                ; set absolute
    G0 Z{z_min_delta} F1800            ; move nozzle to z high first
    G0 X{center_x} Y{center_x} F18000  ; home to get toolhead in the middle
  {% endif %}
  {% if save|lower == 'true' %}
    _PRINT_AR T="BED_MESH: Save Config!"
    SAVE_CONFIG
  {% else %}
    _PRINT_AR T="BED_MESH: Save Config after print done"
    SET_GCODE_VARIABLE MACRO=BED_MESH_STORE VARIABLE=save_at_end VALUE='"true"'
  {% endif %}
#+END_SRC

*** Bed Mesh Load
#+BEGIN_SRC conf
[gcode_macro BED_MESH_LOAD]
description: Load an existing mesh or generate a new one
gcode:
  ##### set default parameter value #####
  {% set auto = params.AUTO|default('false') %}
  {% set bed_temp = printer.heater_bed.target|int %}
  ##### define plate name: Voron (default) or flexplate name #####
  {% set plate_name = 'Voron' %}
  {% if 'save_variables' in printer.configfile.config %}
    {% if printer.save_variables.variables.plate_array is defined %}
      {% set plate_index = printer.save_variables.variables.plate_index|int %}
      {% set plate_name = printer.save_variables.variables.plate_array[plate_index][0] %}
    {% endif %}
  {% endif %}
  ##### join everything to a single mesh name #####
  {% set mesh_name = plate_name + "-Bed_Temp-" + bed_temp|string + "C" %}
  ##### end of definitions #####
  {% if printer.configfile.config["bed_mesh " + mesh_name] is defined %}
    BED_MESH_CLEAR
    BED_MESH_PROFILE LOAD={mesh_name}
    _PRINT_AR T="{"BED_MESH: " + mesh_name + " loaded"}"
  {% else %}
    {% if auto|lower == 'true' %}
      _PRINT_AR T="{"BED_MESH: " + mesh_name + " needs to be generated"}"
      BED_MESH_STORE SAVE=false PARK=false
    {% else %}
      _PRINT_AR T="{"BED_MESH ERROR: " + mesh_name + " not defined"}"
    {% endif %}
  {% endif %}
#+END_SRC

*** Bed Mesh Save
#+BEGIN_SRC conf
[delayed_gcode _BED_MESH_SAVE]
gcode:
  {% if printer["gcode_macro MESH_STORE"].save_at_end == 'true'  %}
    _PRINT_AR T="BED_MESH: Save Config!"
    SAVE_CONFIG
  {% endif %}
#+END_SRC
* Fans
** Hotend Fan - E1 Connector 
#+BEGIN_SRC conf
[heater_fan hotend_fan]
pin: PB0
max_power: 1.0
kick_start_time: 0.5
heater: extruder
heater_temp: 50.0
#+END_SRC

** Print Cooling Fan - Fan0 Connector
#+BEGIN_SRC conf
[fan]
pin: PB1
kick_start_time: 0.5
off_below: 0.10
#+END_SRC

** Controller Board Fan - NeoPixel Connector 5V
#+BEGIN_SRC conf
[heater_fan controller_fan]
pin: PC8
max_power: 1.0
kick_start_time: 0.5
heater: heater_bed
heater_temp: 45.0
#+END_SRC
** Chamber Fan - NeoPixel Connector 24V
#+BEGIN_SRC conf
[thermistor chamber_temp]
temperature1: 25
resistance1: 10000
beta: 3950

[temperature_fan chamber]
pin: PB2
max_power: 1.0
shutdown_speed: 0.0
cycle_time: 0.0005     #2 kHz PWM signal
hardware_pwm: False
sensor_type: chamber_temp
sensor_pin: PC1
min_temp: 0
max_temp: 100
target_temp: 0
max_speed: 1.0
min_speed: 0
control: pid
pid_Kp: 2.0     ;40
pid_Ki: 5.0     ;0.2
pid_Kd: 0.5     ;0.1
pid_deriv_time: 2.0
gcode_id: C
#+END_SRC

*** Macros
Set Chamber Fan Speed
#+BEGIN_SRC conf
[gcode_macro M141]
description: Set temperature of chamber fan
gcode:
  # set default parameter value
  {% set temp = params.S|default(0) %}
  SET_TEMPERATURE_FAN_TARGET temperature_fan=chamber target={temp}
#+END_SRC

Chamber Ventilation Control in Mainsail
#+BEGIN_SRC conf
[gcode_macro VENT]
description: Toggle Chamber fan
gcode:
    {% set act_target = printer['temperature_fan chamber'].target|int %}
    {% set temp_on = printer['gcode_macro _USER_VARIABLE'].vent_on|int %}
    {% if act_target > 0 and act_target <= temp_on %}
        M141
    {% else %}
        M141 S{temp_on}
    {% endif %}
    _VENT_INFO

[delayed_gcode _DELAY_VENT_OFF]
gcode:
  {% if (printer.idle_timeout.state|lower != "printing") %}
    M141
    _VENT_INFO
  {% endif %}

[gcode_macro _VENT_INFO]
description: Helper: Print chamber fan temperature
gcode:
  {% if printer['temperature_fan chamber'].target|int == 0 %}
    {action_respond_info("Chamber fan off")}
  {% else %}
    {action_respond_info("Chamber fan target temp: %2dC" % (printer['temperature_fan chamber'].target))}
  {% endif %}

#+END_SRC

** Nevermore - Off Right Now
#+BEGIN_SRC conf
##  Nevermore Micro filter
##  - Z board, E1 Connector

# [fan_generic filter]
# pin: z:P2.4
# kick_start_time: 0.5
# off_below: 0.10

# [temperature_sensor RPi]
# sensor_type: temperature_host
# min_temp: 10
# max_temp: 100
# gcode_id: PI

# ##  Z board, TH1 Connector
# [temperature_sensor endstop]
# sensor_type: NTC 100K beta 3950
# sensor_pin: z:P0.23
# min_temp: 10
# max_temp: 100
# gcode_id: E
#+END_SRC

*** Macros
Commented Out Right Now

##+BEGIN_SRC conf
[gcode_macro _SET_FILTER]
description: Helper: Set Nevermore filter speed
gcode:
  # set default parameter value
  {% set speed = params.S|default(0) %}
  SET_FAN_SPEED FAN=filter SPEED={speed}

##  Filter On
[gcode_macro _FILTER_ON]
description: Helper: Nevermore on
gcode:
  _SET_FILTER S={printer['gcode_macro _USER_VARIABLE'].filter_on}
  
##  Filter Fan Control in Mainsail
[gcode_macro FILTER]
description: Toggle Nevermore fan
gcode:
  {% if printer['fan_generic filter'].speed|float > 0.0 %}
    _SET_FILTER
  {% else %}
    _FILTER_ON
  {% endif %}
  _FILTER_INFO

[delayed_gcode _DELAY_FILTER_OFF]
gcode:
  {% if (printer.idle_timeout.state|lower != "printing") %}
    _SET_FILTER
    _FILTER_INFO
  {% endif %}
[gcode_macro _FILTER_INFO]
description: Helper: Print Nevermore speed
gcode:
  {% if printer['fan_generic filter'].speed|float > 0.0 %}
    {% set state='on'%}
  {% else %}
    {% set state='off'%}
  {% endif %}
  {action_respond_info("Filter Fan %s" % (state))}
#+END_SRC

** M106 Lock
Dummy output to get an switch in Mainsail
Any unused mcu pin can be defined you will not connect anything
## Off -> M106 will update fan
## On -> M106 can not uodate fan
#+BEGIN_SRC conf
[output_pin lock_M106]
pin: rpi: gpio16
value:0
#+END_SRC



Actual M106 Lock Macro
Allows setting the fan speed and locking it from gcode changes
#+BEGIN_SRC conf
[gcode_macro M106]
description: set fan with manual override and lock option
rename_existing: M106.1
gcode:
  # get params and prepare to send them to the base macro
  {% set get_params = [] %}
  {% for key in params %}
    {% set get_params = get_params.append(key + params[key])  %}
  {% endfor %}
  {%set manual = params.M|default(0) %}
  {% if printer['output_pin lock_M106'].value|int == 0 or manual == '1' %}
    M106.1 {get_params|join(" ")}
  {% else %}
    {action_respond_info("M106 update is locked")}
  {% endif %}
#+END_SRC
** LCD Display Menu
COMMENTED_OUT

##+BEGIN_SRC conf
# ##  Disable stock config
# [menu __main __control __fanonoff]
# type: disabled

# [menu __main __control __fanspeed]
# type: disabled

# ## Add menu for fan, chamber and filter
# [menu __main __control __fan]
# type: list
# name: Fan 
# index: 5

# [menu __main __control __fan __partcooling]
# type: list
# enable: {'fan' in printer}
# name: Fan {'%3d' % (printer.fan.speed*100)}%

# [menu __main __control __fan __chamber]
# type: list
# enable: {'temperature_fan chamber' in printer}
# name: Chamber {'%2dC' % (printer['temperature_fan chamber'].target) if printer['temperature_fan chamber'].target else 'OFF'}

# [menu __main __control __fan __filter]
# type: list
# enable: {'fan_generic filter' in printer}
# name: Filter {'%3d' % (printer['fan_generic filter'].speed*100)}%

# [menu __main __control __fan __partcooling __fanonoff]
# type: input
# name: Toggle: {'ON' if menu.input else 'OFF'}
# input: {printer.fan.speed}
# input_min: 0
# input_max: 1
# input_step: 1
# gcode:
#   M106 S{255 if menu.input else 0}

# [menu __main __control __fan __partcooling __fanspeed]
# type: input
# name: Speed: {'%3d' % (menu.input*100)}%
# input: {printer.fan.speed}
# input_min: 0
# input_max: 1
# input_step: 0.01
# gcode:
#   M106 S{'%d' % (menu.input*255)}

# [menu __main __control __fan __chamber __chamberonoff]
# type: input
# name: Toggle: {'ON' if menu.input else 'OFF'}
# input: {printer['temperature_fan chamber'].target}
# input_min: 0
# input_max: 1
# input_step: 1
# gcode:
#   {% set temp_on = printer["gcode_macro _USER_VARIABLE"].vent_on|int %}
#   M141 S{temp_on if menu.input else 0}    
    
# [menu __main __control __fan __chamber __chamberfanspeed]
# type: input
# name: Temp: {'%2dC' % (menu.input) if menu.input else 'OFF'}
# input: {printer['temperature_fan chamber'].target}
# input_min: {printer.configfile.settings['temperature_fan chamber'].min_temp|int}
# input_max: {printer.configfile.settings['temperature_fan chamber'].max_temp|int}
# input_step: 1
# gcode:
#     M141 S{'%d' % (menu.input)}

# [menu __main __control __fan __filter __filteronoff]
# type: input
# name: Toggle: {'ON ' if menu.input else 'OFF'}
# input: {printer['fan_generic filter'].speed}
# input_min: 0
# input_max: 1
# input_step: 1
# gcode:
#  {% if menu.input %}
#    _FILTER_ON
#  {% else %}
#    _SET_FILTER S=0.0
#  {% endif %}

# [menu __main __control __fan __filter __filterspeed]
# type: input
# name: Speed: {'%3d' % (menu.input*100)}%
# input: {printer['fan_generic filter'].speed}
# input_min: 0
# input_max: 1
# input_step: 0.01
# gcode:
#     _SET_FILTER S={menu.input}
#+END_SRC
* Lights
** Case Light
##+BEGIN_SRC conf
[output_pin caselight]
pin: !rpi: gpio24
pwm: false
shutdown_value: 0
#+END_SRC

*** Macros
##+BEGIN_SRC conf
[gcode_macro _CASELIGHT_ON]
description: Helper: Light on
gcode:
  SET_PIN PIN=caselight VALUE=1.0
  {action_respond_info("Caselight on")}
    
[gcode_macro _CASELIGHT_OFF]
description: Helper: Light off
gcode:
  SET_PIN PIN=caselight VALUE=0.0
  {action_respond_info("Caselight off")}

[gcode_macro CASELIGHT]
description: Toggle light
gcode:
  {%if printer['output_pin caselight'].value == 0 %}
    _CASELIGHT_ON
  {% else %}
    _CASELIGHT_OFF
  {% endif %}

[delayed_gcode _CASELIGHT_ON_FIRMWARE_START]
initial_duration: 1
gcode:
  _CASELIGHT_ON
#+END_SRC

*** Display Menu Definition
COMMENTED_OUT
##+BEGIN_SRC conf
# [menu __main __control __caselightonoff]
# type: input
# enable: {'output_pin caselight' in printer}
# name: Lights: {'ON ' if menu.input else 'OFF'}
# input: {printer['output_pin caselight'].value}
# input_min: 0
# input_max: 1
# input_step: 1
# gcode:
#     {% if menu.input %}
#       _CASELIGHT_ON
#     {% else %}
#       _CASELIGHT_OFF
#     {% endif %}
#+END_SRC
* Input Shaper
#+BEGIN_SRC conf
[adxl345]
cs_pin: rpi:None
##  The SPI speed (in hz) to use when communicating with the chip.
##  The default is 5000000.
#spi_speed: 5000000
## Output data rate for ADXL345. ADXL345 supports the following data
##  rates: 3200, 1600, 800, 400, 200, 100, 50, and 25. Note that it is
## not recommended to change this rate from the default 3200, and
##  rates below 800 will considerably affect the quality of resonance
##  measurements.
#rate: 3200
##  The accelerometer axis for each of the printer's x, y, and z axes.
##  This may be useful if the accelerometer is mounted in an
##  orientation that does not match the printer orientation. For
##  example, one could set this to "y,x,z" to swap the x and y axes.
##  It is also possible to negate an axis if the accelerometer
##  direction is reversed (eg, "x,z,-y"). The default is "x,y,z".
##  receck
axes_map: x,y,z

#####################################################################
#  resonance tester definition
#####################################################################
[resonance_tester]
accel_chip: adxl345
##  A list of X,Y,Z coordinates of points (one point per line) to test
##  resonances at. At least one point is required. Make sure that all
##  points with some safety margin in XY plane (~a few centimeters)
##  are reachable by the toolhead.
probe_points:  
    150,150,20
#    175,175,160
#    175,175,300
##  Maximum input shaper smoothing to allow for each axis during shaper
##  auto-calibration (with 'SHAPER_CALIBRATE' command). By default no
##  maximum smoothing is specified. Refer to Measuring_Resonances guide
##  for more details on using this feature.
#max_smoothing:
##  Minimum/Maximum frequency to test for resonances.
min_freq: 5
max_freq: 133
##  This parameter is used to determine which acceleration to use to
##  test a specific frequency: accel = accel_per_hz * freq. Higher the
##  value, the higher is the energy of the oscillations. Can be set to
##  a lower than the default value if the resonances get too strong on
##  the printer. However, lower values make measurements of
##  high-frequency resonances less precise. The default value is 75
##  (mm/sec).
accel_per_hz: 75
##  Determines the speed of the test. When testing all frequencies in
##  range [min_freq, max_freq], each second the frequency increases by
##  hz_per_sec. Small values make the test slow, and the large values
##  will decrease the precision of the test. The default value is 1.0
##  (Hz/sec == sec^-2).
hz_per_sec: 1

#####################################################################
#  input shaper  definition
#####################################################################
[input_shaper]
##  A frequency (in Hz) of the input shaper for X or Y axis. 
shaper_freq_x: 59.4
shaper_freq_y: 46.2
##  A type of the intput shaper for X or Y axia.
shaper_type_x: mzv
shaper_type_y: zv
##  Damping ratios of vibrations of X and Y axes used by input shapers
##  to improve vibration suppression. Default value is 0.1 which is a
##  good all-round value for most printers. In most circumstances this
##  parameter requires no tuning and should not be changed.
#damping_ratio_x: 0.1
#damping_ratio_y: 0.1
#+END_SRC

** Macros
#+BEGIN_SRC conf
# !!! This macro only works with the use of gcode_shell_command.py !!!
# you find both needed files at /klipper_config/script
#  - gcode_shell_command.py -> klipper add on file
#  - plot_graph.sh -> shell script that is executed
# 
# Setup:
#  - symlink or copy gcode_shell_command.py to /klipper/klippy/extra
#    e.g  ln -s /home/pi/klipper_config/script/gcode_shell_command.py /home/pi/klipper/klippy/extras/gcode_shell_command.py
#  - klipper service restart
#
# Please inspect the shell scrip by your own and use it by your own risk
# Functions:
#  - Remove _old files if exists
#  - rename the current files to _old
#  - copy current cvs files from /tmp to the specified folder
#  - run the calibrate_shaper.py to generate the graphs and store them at the same location
#####################################################################
[gcode_macro RESONANCES_TEST]
description: Run input shaper test
gcode:
  #############  Get hardware enables  #############
  {% set ena_chamber = printer['gcode_macro _USER_VARIABLE'].chamber|lower %}
  {% set ena_filter = printer['gcode_macro _USER_VARIABLE'].filter|lower %}
  ## TEST_RESONANCES will set the accel and accel_to decel
  _CG28                                                  ; home if needed
  TURN_OFF_HEATERS                                       ; turn off heaters
  M107                                                   ; turn off fan
  {% if ena_chamber == 'fan' %} M141 {% endif %}         ; exhaust fan off
  {% if ena_filter == 'true' %} _SET_FILTER {% endif %}  ; filter off
  _PRINT_AR T="INPUT SHAPER: Noise values, check if sensor is installed"
  MEASURE_AXES_NOISE                                     ; get noise value in log
  _PRINT_AR T="INPUT SHAPER: Resonance Tests starting ..."
  TEST_RESONANCES AXIS=X                                 ; measure X 
  TEST_RESONANCES AXIS=Y                                 ; measure Y
  _PRINT_AR T="INPUT SHAPER: Resonance Tests done"
  _PRINT_AR T="INPUT SHAPER: Generate graph in backround"
  RUN_SHELL_COMMAND CMD=plot_graph

## Shell Comand is not supported by a default klipper installation 
[gcode_shell_command plot_graph]
command: sh /home/pi/klipper_config/script/plot_graph.sh
timeout: 30.
verbose: True
#+END_SRC  
  
* Filament
** Retraction Settings
#+BEGIN_SRC conf
[firmware_retraction]
#   The length of filament (in mm) to retract when G10 is activated,
#   and to unretract when G11 is activated
retract_length: 0.75
#   The length (in mm) of *additional* filament to add when
#   unretracting.
unretract_extra_length: 0
retract_speed: 70
unretract_speed: 40
#+END_SRC
** Load and Unload Macros
#+BEGIN_SRC conf
[gcode_macro FILAMENT_LOAD]
description: Load filament and disable rounout while running
gcode:
  ##### get user defines #####
  {% set add_temp = printer['gcode_macro _USER_VARIABLE'].extruder_min_add|int %}
  {% set load = printer['gcode_macro _USER_VARIABLE'].load_distance %}
  {% set extrude = printer['gcode_macro _USER_VARIABLE'].load_extrude %}
  {% set retreact = printer['gcode_macro _USER_VARIABLE'].retreact_end|float * -1 %}
  {% set purge_pos = printer['gcode_macro _USER_VARIABLE'].purge %}
  {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop %}
  ##### get hardware enables #####
  {% set ena_neo = printer['gcode_macro _USER_VARIABLE'].neo_display|lower %}
  {% set ena_runout = printer['gcode_macro _USER_VARIABLE'].runout|lower %}
  ##### get toolhead position #####
  {% set act_z = printer.toolhead.position.z|float %}
  ##### store extruder temps #####
  {% set minTemp = printer.configfile.settings.extruder.min_extrude_temp|int + add_temp %}
  {% set extruder_target = printer.extruder.target %}
  ##### calc movement high #####
  {% if act_z < z_hop %}
    {% set move_z = z_hop %}
  {% else %}
    {% set move_z = act_z %}
  {% endif %}
  ##### end of definitions #####

  ## Disable printing check for multimaterial
  # {% if printer.idle_timeout.state != "Printing" or printer.pause_resume.is_paused|lower == "true" %}
  SAVE_GCODE_STATE NAME=STATE_LOAD_FILAMENT
  {% if ena_runout == 'motion' %}
    SET_FILAMENT_SENSOR SENSOR=runout ENABLE=0
  {% endif %}
  ## Move to waste bin
  _CG28                                    ; home if not already homed
  G90                                      ; absolute positioning
  G1 Z{move_z} F1800                       ; move head to minimum
  G1 X{purge_pos[0]} Y{purge_pos[1]} F9000 ; move to purge bucket location
  {% if ena_neo == 'true' %} _LCD_KNOB COLOR=BLUE {% endif %}
  {% if printer.extruder.can_extrude|lower == 'false' %}
    {action_respond_info("Extruder Temp to low heat to %2dC" % minTemp)}
    M109 S{minTemp} ; heat extruder and wait
  {% endif %}
  {% if ena_neo == 'true' %} _LCD_KNOB COLOR=RESTORE {% endif %}
  G1 Z{purge_pos[2]} F1800 
  M83                  ; set extruder to relative
  G1 E{load} F1800     ; quickly load 90mm filament
  G1 E{extrude} F300   ; slower extrusion for hotend path
  G1 E{retreact} F1000 ; retract 
  SAVE_VARIABLE VARIABLE=filament_loaded VALUE='"true"'
  # clean nozzle
  _WIPE
  G1 Z{move_z} F1800        
  G1 X{purge_pos[0]} Y{purge_pos[1]} F9000 ; move to purge bucket location
  # restore old extruder temperature
  M109 S{extruder_target}
  {% if ena_runout == 'motion' %}
    _PRINT_AR T="RUNOUT Motion Sensor Enable: true"
    SET_FILAMENT_SENSOR SENSOR=runout ENABLE=1
  {% endif %}
  _PRINT_AR T="Filament loaded"
  RESTORE_GCODE_STATE NAME=STATE_LOAD_FILAMENT

  # {% else %}
  #   _PRINT_AR T="Filament loading disabled while printing!"
  # {% endif %}
 
[gcode_macro FILAMENT_UNLOAD]
description: Unload filament and disable rounout while running
gcode:
  ##### get user defines #####
  {% set add_temp = printer['gcode_macro _USER_VARIABLE'].extruder_min_add|int %}
  {% set unload = printer['gcode_macro _USER_VARIABLE'].unload_distance %}
  ##### get hardware enables #####
  {% set ena_neo = printer['gcode_macro _USER_VARIABLE'].neo_display|lower %}
  {% set ena_runout = printer['gcode_macro _USER_VARIABLE'].runout|lower %}
  ##### store extruder temps #####
  {% set minTemp = printer.configfile.settings.extruder.min_extrude_temp|int + add_temp %}
  {% set extruder_target = printer.extruder.target %}
  ##### end of definitions #####

  ## Disabled the printing check for multimaterial
  #{% if printer.idle_timeout.state != "Printing" or printer.pause_resume.is_paused|lower == "true" %}
  SAVE_GCODE_STATE NAME=STATE_UNLOAD_FILAMENT
  {% if ena_runout == 'motion' %}
    _PRINT_AR T="RUNOUT Motion Sensor Enable: false"
    SET_FILAMENT_SENSOR SENSOR=runout ENABLE=0
  {% endif %}
  {% if ena_neo == 'true' %} _LCD_KNOB COLOR=BLUE {% endif %}
  {% if printer.extruder.can_extrude|lower == 'false' %}
    {action_respond_info("Extruder Temp to low heat to %2dC" % minTemp)}
    M109 S{minTemp} ; heat extruder and wait
  {% endif %}
  # Ball up the filament tip and retract out past the extruder gears
  {% if ena_neo == 'true' %} _LCD_KNOB COLOR=RESTORE {% endif %}
  _FILAMENT_BALL WAIT=3
  M83 ; Relative extrusion
  G1 E-{unload} F3000
  M400
  SAVE_VARIABLE VARIABLE=filament_loaded VALUE='"false"'
  # restore old extruder temperature
  M109 S{extruder_target}
  _PRINT_AR T="Filament unloaded"
  RESTORE_GCODE_STATE NAME=STATE_UNLOAD_FILAMENT

  # {% else %}
  #   _PRINT_AR T="Filament unloading disabled while printing!"
  # {% endif %}

#+END_SRC
** Nozzle Clean
#+BEGIN_SRC conf
[gcode_macro NOZZLECLEAN]
description: Move to bucket and scrub nozzle
gcode:
  ##### get user defines #####
  {% set add_temp = printer['gcode_macro _USER_VARIABLE'].extruder_min_add|int %}
  {% set purge_pos = printer['gcode_macro _USER_VARIABLE'].purge %}
  {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop %}
  ##### store extruder temps #####
  {% set minTemp = printer.configfile.settings.extruder.min_extrude_temp|int + add_temp %}
  {% set extruder_target = printer.extruder.target %}
  ##### get toolhead position #####
  {% set act_z = printer.toolhead.position.z|float %}
  ##### end of definitions #####
  SAVE_GCODE_STATE Name=STATE_NOZZLECLEAN
  _PRINT_AR T="Clean Nozzle" SHOW_LCD=true
  _CG28                                    ; home if not already homed
  G90                                      ; absolute positioning
  {% if act_z < z_hop %}
    G1 Z{z_hop} F900                       ; move head up
  {% endif %}
  G1 X{purge_pos[0]} Y{purge_pos[1]} F9000 ; move to purge bucket location
  {% if printer.extruder.can_extrude|lower == 'false' %}
      {action_respond_info("Extruder Temp to low heat to %2dC" % minTemp)}
      M109 S{minTemp}      ; heat extruder and wait
  {% endif %}
  G1 Z{purge_pos[2]} F900  ; lower Z
  G92 E0                   ; reset Extruder
  M83                      ; relative extrusion
  G1 E5.00 F500            ; purge filament (5mm)
  G1 E5.00 F800            ; purge filament (5mm)
  G1 E-0.5 F800            ; retract filament (0.5)
  G4 P500
  _WIPE
  # restore old extruder temperature
  M109 S{extruder_target}
  UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=1
  RESTORE_GCODE_STATE Name=STATE_NOZZLECLEAN

[gcode_macro _WIPE]
description: Helper: Wipe nozzle at bucket
gcode:
  ##### get user defines #####
  {% set wipe_cnt = printer['gcode_macro _USER_VARIABLE'].wipe_cnt|int %}
  {% set wipe_start_pos = printer['gcode_macro _USER_VARIABLE'].wipe_start %}
  {% set wipe_end_pos = printer['gcode_macro _USER_VARIABLE'].wipe_end %}
  {% set wipe_offset = printer['gcode_macro _USER_VARIABLE'].wipe_offset|float %}
  ##### end of definitions #####
  G90 ; absolute positioning
  G0 X{wipe_start_pos[0]} Y{wipe_start_pos[1]} Z{wipe_start_pos[2]} F4000
  # move head diagonal to brush
  {% for wipe in range(0, wipe_cnt) %}
    {% for coordinate in [wipe_start_pos[0], wipe_end_pos[0]] %}
      G0 X{coordinate} Y{wipe_start_pos[1] + wipe_offset * wipe} F4000
    {% endfor %}
  {% endfor %}
  G0 X{wipe_end_pos[0]} Y{wipe_end_pos[1]} Z{wipe_end_pos[2]} F4000
#+END_SRC
** Priming
#+BEGIN_SRC conf
[gcode_macro PRIME_LINE]
description: Purge nozzle front left
gcode:
  ##### get user defines #####
  {% set start_xy = printer['gcode_macro _USER_VARIABLE'].prime_start_xy %}
  {% set dir = printer['gcode_macro _USER_VARIABLE'].prime_dir|string %}
  {% set lenght = printer['gcode_macro _USER_VARIABLE'].prime_lenght|float %}
  {% set seg = printer['gcode_macro _USER_VARIABLE'].prime_seg|int %}
  {% set extrude_per_seg = printer['gcode_macro _USER_VARIABLE'].prime_extrude_per_seg|float %}
  {% set prime_z = printer['gcode_macro _USER_VARIABLE'].prime_z|float %}
  {% set move_between_lines = printer['gcode_macro _USER_VARIABLE'].prime_dist|float %}
  {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
  ##### get parameter and set default #####
  {% set prime_height = params.PRIME_HEIGHT|default(prime_z)|float %}
  ##### get toolhead position #####
  {% set act_z = printer.toolhead.position.z|float %}
  ##### calculate prime line moves #####
  {% set seg_delta = lenght / seg %}
  {% if dir == 'X+' %}
    {% set first_line = 'X%s E%s F1500' % (seg_delta, extrude_per_seg) %}
    {% set second_line = 'X-%s E%s F1500' % (seg_delta, extrude_per_seg) %}
    {% set move_to_side = 'Y%s' % (move_between_lines) %}
  {% elif dir == 'X-' %}
    {% set first_line = 'X-%s E%s F1500' % (seg_delta, extrude_per_seg) %}
    {% set second_line = 'X%s E%s F1500' % (seg_delta, extrude_per_seg) %}
    {% set move_to_side = 'Y%s' % (move_between_lines) %}
  {% elif dir == 'Y+' %}
    {% set first_line = 'Y%s E%s F1500' % (seg_delta, extrude_per_seg) %}
    {% set second_line = 'Y-%s E%s F1500' % (seg_delta, extrude_per_seg) %}
   {% set move_to_side = 'X%s' % (move_between_lines) %}
  {% elif dir == 'Y-' %}
    {% set first_line = 'Y-%s E%s F1500' % (seg_delta, extrude_per_seg) %}
    {% set second_line = 'Y%s E%s F1500' % (seg_delta, extrude_per_seg) %}
    {% set move_to_side = 'X%s' % (move_between_lines) %}
  {% else %}
    {action_raise_error("_USER_VARIABLE.prime_dir is not spezified as X+, X-, Y+ or Y-")}
  {% endif %} 
  ##### end of definitions #####
  _PRINT_AR T="Prime Line" SHOW_LCD=true
  _CG28                                   ; home if not already homed
  G92 E0                                  ; reset Extruder
  G90                                     ; absolute positioning
  {% if act_z < z_hop %}
    G1 Z{z_hop} F900                      ; move head up
  {% endif %}
  G1 X{start_xy[0]} Y{start_xy[1]} F18000 ; move to start position
  G1 Z{prime_height} F900                 ; move Z Axis down
  G91                                     ; relative positioning
  {% for segment in range(seg) %}         ; draw the first line
    G1 {first_line}
  {% endfor %}    
  G1 {move_to_side}                       ; move to side
  {% for segment in range(seg) %}         ; draw the second line
    G1 {second_line}
  {% endfor %}
  G1 Z{z_hop} F1500                       ; move Z Axis up
  G92 E0                                  ; reset Extruder
  UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=1

[gcode_macro PRIME_BALL]
description: Purge nozzle in ball line
gcode:
  ##### get user defines #####
  {% set z_hop = printer['gcode_macro _USER_VARIABLE'].z_hop|float %}
  #{% set start_xy = printer['gcode_macro _USER_VARIABLE'].prime_start_xy %}
  #{% set end_xy = printer['gcode_macro _USER_VARIABLE'].prime_end_xy %}
  #{% set ex = printer['gcode_macro _USER_VARIABLE'].prime_extrusion_amount %}
  #{% set prime_z = printer['gcode_macro _USER_VARIABLE'].prime_z|float %}
  ##### get toolhead position #####
  #{% set act_z = printer.toolhead.position.z|float %}

  _PRINT_AR T="Prime Ball" SHOW_LCD=true
  _CG28                                   ; home if not already homed
  G92 E0                                  ; reset Extruder
  G90                                    ; absolute positioning
  #{% if act_z < z_hop %}
  #  G1 Z{z_hop} F900                      ; move head up
  #{% endif %}
  G1 X55 Y3 Z0.85 F12000 ; move to start position
  G1 X75 Y3 E40 F100 ; Extrude amount
  G92 E0
  G1 X80 F18000;
  G1 Z{z_hop} F1500                       ; move Z Axis up
  UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=1

[gcode_macro _FILAMENT_BALL]
description: Helper: Round the filament tip
gcode:
  ##### set default parameter value #####
  {% set wait = params.WAIT|default(0) %}
  ##### end of definitions #####
  SAVE_GCODE_STATE NAME=STATE_FILAMENT_BALL
  # Ball up the filament tip
  G92 E0       ; zero the extruder
  M82          ; absolute extrusion
  G1 E2 F3600
  G1 E0 F3600
  G1 E4 F3600
  G1 E0 F3600
  G1 E8 F3600
  G1 E0 F3600
  M83          ; relative extrusion
  G1 E-25 F3600
  G4 P{wait|int * 1000}
  RESTORE_GCODE_STATE NAME=STATE_FILAMENT_BALL
#+END_SRC
** Filament Change
#+BEGIN_SRC conf
[gcode_macro M600]
description: Filament change
gcode:
  PAUSE Y=10   ; everything needed is defined there
#+END_SRC
** Runout Sensor
#+BEGIN_SRC conf
#[filament_switch_sensor runout]
##   When set to True, a PAUSE will execute immediately after a runout
##   is detected. Note that if pause_on_runout is False and the
##   runout_gcode is omitted then runout detection is disabled. Default
##   is True.
#pause_on_runout: FALSE
#runout_gcode:
#  {action_respond_info("RUNOUT Switch Sensor: Filament runout")}
#  PAUSE
#insert_gcode:
#  {action_respond_info("RUNOUT Switch Sensor: Filament inserted")}
##   The minimum amount of time in seconds to delay between events.
##   Events triggered during this time period will be silently
##   ignored. The default is 3 seconds.
##event_delay: 3.0
##   The amount of time to delay, in seconds, between the pause command
##   dispatch and execution of the runout_gcode. It may be useful to
##   increase this delay if OctoPrint exhibits strange pause behavior.
##   Default is 0.5 seconds.
##pause_delay: 0.5
##    XYE mcu E0DET
#switch_pin: ^!P1.26

# [filament_motion_sensor runout]
# #   The minimum length of filament pulled through the sensor to trigger
# #   a state change on the switch_pin
# #   Default is 7 mm.
# detection_length: 7.0
# extruder: extruder
# pause_on_runout: FALSE
# runout_gcode:
#   {action_respond_info("RUNOUT Motion Sensor: Filament runout")}
#   PAUSE
# insert_gcode:
#   {action_respond_info("RUNOUT Motion Sensor: Filament inserted")}
# #   The minimum amount of time in seconds to delay between events.
# #   Events triggered during this time period will be silently
# #   ignored. The default is 3 seconds.
# #event_delay: 3.0
# #   The amount of time to delay, in seconds, between the pause command
# #   dispatch and execution of the runout_gcode. It may be useful to
# #   increase this delay if OctoPrint exhibits strange pause behavior.
# #   Default is 0.5 seconds.
# #pause_delay: 0.5
# ##    XYE mcu E0DET
# switch_pin: ^!P1.26
#+END_SRC
*** Display Menu Stuff
#+BEGIN_SRC conf
#####################################################################
# 	LCD Menu
#####################################################################   
# [menu __main __control __runoutonoff_switch]
# type: input
# enable: {'filament_switch_sensor runout' in printer.configfile.settings}
# name: Runout: {'ON ' if menu.input else 'OFF'}
# input: {printer['filament_switch_sensor runout'].enabled}
# input_min: 0
# input_max: 1
# input_step: 1
# index: 4
# gcode:
#   SET_FILAMENT_SENSOR SENSOR=runout ENABLE={menu.input|int}
  
# [menu __main __control __runoutonoff_motion]
# type: input
# enable: {'filament_motion_sensor runout' in printer.configfile.settings}
# name: Runout: {'ON ' if menu.input else 'OFF'}
# input: {printer['filament_motion_sensor runout'].enabled}
# input_min: 0
# input_max: 1
# input_step: 1
# index: 4
# gcode:
#   SET_FILAMENT_SENSOR SENSOR=runout ENABLE={menu.input|int}
#+END_SRC
* Other Macros
** Basic Macros
Basic Macros, needed by other files.  Mostly for console output.
#+BEGIN_SRC conf
##  Clear display output after Duration in seconds  
##  Use: UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=1
[delayed_gcode _CLEAR_DISPLAY]
gcode:
  M117

## Reset SD File after Print_END or CANCEL_PRINT
## This will avoid the reprint option in Mainsail after a print is done
[delayed_gcode _DELAY_SDCARD_RESET_FILE]
gcode:
  SDCARD_RESET_FILE
  
##  action_respond_info will be always executed at the befinning 
##  of an macro evaluation. Use _PRINT_AR if you need the order 
##  of several console outputs in the order given by the macro
##  Use: _PRINT_AR T="QGL forced by PRINT_START"
[gcode_macro _PRINT_AR]
description: Helper: Action response 
gcode:
  #####  set defaults  #####
  {% set show_lcd = params.SHOW_LCD|default('false') %}
  {% if show_lcd == 'true' %}
    M117 {'%s' % (params.T|string)}
  {% endif %}
  {action_respond_info("%s" % (params.T|string))}

##  print runout sensor information in any case even is no
##  runout is specified
[gcode_macro _RUNOUT_INFO]
description: Helper: Print runout sensor status
gcode:
  #############  Get hardware enables  #############
  {% set ena_runout = printer['gcode_macro _USER_VARIABLE'].runout|lower %}
  #############  Generate output varibles  #############
  {% if ena_runout == 'switch' %}
    {% set enabled = printer['filament_switch_sensor runout'].enabled|lower %}
    {% set sensor = 'Switch Sensor' %}
    {% if printer['filament_switch_sensor runout'].enabled|lower == 'true' %}
      {% set filament_detected = printer['filament_switch_sensor runout'].filament_detected|lower %}
    {% elif 'virtual_sdcard' in printer and filament_loaded in printer.save_variables.variables %}
      {% set filament_detected = printer.save_variables.variables.filament_loaded %}
    {% else %}
      {% set filament_detected = 'unknown' %}
    {% endif %}
  {% elif ena_runout == 'motion' %}
    {% set enabled = printer['filament_motion_sensor runout'].enabled|lower %}
    {% set sensor = 'Motion Sensor' %}
    {% if printer['filament_motion_sensor runout'].enabled|lower == 'true' %}
      {% set filament_detected = printer['filament_motion_sensor runout'].filament_detected|lower %}
    {% elif 'virtual_sdcard' in printer and filament_loaded in printer.save_variables.variables %}
      {% set filament_detected = printer.save_variables.variables.filament_loaded %}
    {% else %}
      {% set filament_detected = 'unknown' %}
    {% endif %}
  {% elif ena_runout == 'file' %}
    {% set filament_detected = printer.save_variables.variables.filament_loaded %}
    {% set enabled = 'false' %}
    {% set sensor = 'Stored in file' %}
  {% else %}
    {% set filament_detected = 'unknown' %}
    {% set enabled = 'false' %}
    {% set sensor = 'Not monitored' %}
  {% endif %}
  #############  End of definition  #############
  {action_respond_info("RUNOUT: %s
                        Enabled: %s
                        Detect Filament: %s" % (sensor, enabled|lower,filament_detected|lower))}

##  adds version info of mcu to M115
[gcode_macro M115]
description: Print host and mcu version
rename_existing: M115.1
gcode:
  {% set parameters = namespace(output = 'mcu build version: \n') %}
  {% for name1 in printer %}
    {% for name2 in printer[name1] %}
      {% set show = ['mcu_version'] %}
      {% if name2 is in show %}
        {% set param = "%s: %s" % (name1, printer[name1][name2]) %}
        {% set parameters.output = parameters.output +  param + "\n" %}
      {% endif %}
    {% endfor %}
  {% endfor %}
  {action_respond_info(parameters.output)}
  M115.1
#+END_SRC
** Print Macros
*** Print Start
#+BEGIN_SRC conf
  [gcode_macro PRINT_START]
  description: All commands needed before the print
  variable_extruder: 245
  variable_bed: 100
  variable_chamber: 40
  variable_endstop: 0
  variable_prime_height: 0
  variable_z_adjust: 0.0
  gcode:
    {% set park_pos = printer['gcode_macro _USER_VARIABLE'].park_bed %}

    {% set bed_temp = params.BED_TEMP|default(100)|int %}
    {% set extruder_temp = params.EXTRUDER_TEMP|default(245)|int %}
    {% set chamber_temp = params.CHAMBER_TEMP|default(60)|int %}
    {% set p_height = params.LAYER_HEIGHT|default(0.2)|float %}
    {% set adjust_z = params.Z_ADJUST|default(0.0)|float %}

    M117 Homing
    _CG28                                   ; home if needed
    # Move to Middle
    G90
    M117 Parking
    G0 Z{park_pos[2]} F1800                 ; move nozzle to z high first
    G0 X{park_pos[0]} Y{park_pos[1]} F18000 ; home to get toolhead in the middle

    M117 Heating Extruder
    M140 S{bed_temp}      ; heat bed
    M109 S{extruder_temp} ; heat extruder and wait

    M117 Heating Bed
    M190 S{bed_temp}      ; heat bed and wait
    M400                  ; wait for buffer to clear

    M106 S0                                                   ; turn off part cooling fan
    G21                                                       ; set units to millimeters
    G32                                                       ; home & QGL
    M141 S{chamber}                                           ; set target temp for exhaust fan
    NOZZLECLEAN
    G28 Z                                                     ; home Z with clean nozzle
    CALIBRATE_Z                                               ; Calibrate Z Height
    SET_GCODE_OFFSET Z_ADJUST={z_adjust} MOVE=1
    _PRINT_OFFSET
    BED_MESH_PROFILE LOAD=default
    {% if prime_height > 0 %}
      PRIME_LINE PRIME_HEIGHT={p_height}
      #PRIME_BALL
    {% else %}
      #PRIME_BALL
      PRIME_LINE
    {% endif %}
    G90                                                       ; use absolute coordinates
    ;M83                                                       ; use relative distances for extrusion
#+END_SRC
**** old print start
  ##+BEGIN_SRC conf
    [gcode_macro PRINT_START]
    description: All commands needed before the print
    ##  User Paramaters
    ##  BED_TEMP      : Target temperature for the Bed. Is also used to decide 
    ##                  if heatsoak is needed
    ##  EXTRUDER_TEMP : Target temperature for the Extruder
    ##  CHAMBER_TEMP  : Target temperature for the chamber fan controll
    ##  SOAK          : Soak time in minutes
    ##  DELTA_B       : Allowed delta between actual bed temperature and target
    ##                  temperature for the decision if heat soak is needed.
    ##  DELTA_C       : Allowed delta between actual chamber temperature and target
    ##                  will wait until target reached or time is zero
    ##  CHAMBER_SOAK  : Extra Soak time if Chamber is not on target - DELTA_C
    ##  EXTRA_SOAK    : Enables Chamber Soak ('true'/'false')
    ##  LAYER_HEIGHT  : Height of prime_line should be set to layer_hight
    ##  Z_ADJUST      : Add extra z offset via slicer
    ##  System Varables
    variable_extruder: 245
    variable_bed: 100
    variable_chamber: 40
    variable_chamber_delta: 5
    variable_redo_qgl: 'false'
    variable_soak_tval: 0
    variable_soak_tval_c: 0
    variable_endstop: 0
    variable_print_info: 'true'
    variable_prime_height: 0
    variable_z_adjust: 0.0
    ## Valid state 
    ##   Prepare : decision if heat Soak is needed 
    ##   HeatSoak: loop the time specified with SOAK
    ##   Chamber : wait for chamber reached CHAMBER_SOAK 
    ##   Final   : all what needs to be done after wait timet
    variable_state: 'Prepare'
    gcode:
      #############  Get user defines  #############
      {% set park_pos = printer['gcode_macro _USER_VARIABLE'].park_bed %}
      {% set soak_ival = printer['gcode_macro _USER_VARIABLE'].print_start_ival|int %}
      {% set soak_bed_up = printer['gcode_macro _USER_VARIABLE'].print_start_bed_up|int %}
      {% set extuder_start_time = printer['gcode_macro _USER_VARIABLE'].print_start_extruder_time|int * 60 %}
      {% set bed_reduce_time = printer['gcode_macro _USER_VARIABLE'].print_start_bed_time|int * 60 %}
      {% set prime_mult = printer['gcode_macro _USER_VARIABLE'].print_start_prime_mult|float %}
      #############  Get hardware enables  #############
      {% set ena_neo = printer['gcode_macro _USER_VARIABLE'].neo_display|lower %}
      {% set ena_chamber = printer['gcode_macro _USER_VARIABLE'].chamber|lower %}
      {% set ena_caselight = printer['gcode_macro _USER_VARIABLE'].caselight|lower %}
      {% set ena_filter = printer['gcode_macro _USER_VARIABLE'].filter|lower %}
      {% set ena_runout = printer['gcode_macro _USER_VARIABLE'].runout|lower %}
      {% set ena_relay = printer['gcode_macro _USER_VARIABLE'].relay|lower %}
      {% set ena_auto_z_offset = printer['gcode_macro _USER_VARIABLE'].auto_z_offset|lower %}
      #############  BED temp values  #############
      # get actual temp from extra sensor or heater sensor
      {% if 'temperature_sensor bed' in printer %}
	{% set actBed = printer['temperature_sensor bed'].temperature|int %}
      {% else %}
	{% set actBed = printer.heater_bed.temperature|int %}
      {% endif %}
      # get max allow bed temp from config. Lower it by 5C to avoid shutdown
      {% set cfg_bed_max = printer.configfile.settings.heater_bed.max_temp|int - 5 %}
      #############  Definition done  #############
      ##  Prepare phase only done at the first exection of PRINT_START
      {% if state == 'Prepare' %}
	#############  Store input parameters only at first execution  #############
	{% set bed_temp = params.BED_TEMP|default(100)|int %}
	{% set extruder_temp = params.EXTRUDER_TEMP|default(245)|int %}
	{% set chamber_temp = params.CHAMBER_TEMP|default(60)|int %}
	{% set soak = params.SOAK|default(0)|int * 60 %}
	{% set delta_b = params.DELTA_B|default(0)|int %}
	{% set delta_c = params.DELTA_C|default(0)|int %}
	{% set chamber_soak = params.CHAMBER_SOAK|default(0)|int * 60 %}
	{% set extra_soak = params.EXTRA_SOAK|default('false') %}
	{% set p_height = params.LAYER_HEIGHT|default(0.2)|float * prime_mult %}
	{% set adjust_z = params.Z_ADJUST|default(0.0)|float %}
	#############  Variable Setup  #############
	{% set targetBed = bed_temp - delta_b %}
	{% if cfg_bed_max > bed_temp + soak_bed_up %}
	  {% set bed_soak_temp = bed_temp + soak_bed_up %}
	{% else %}
	  {% set bed_soak_temp = cfg_bed_max %}
	{% endif %}
	############# Store Values for the complete PRINT_START execution #############
	SET_GCODE_VARIABLE MACRO=CANCEL_PRINT VARIABLE=execute VALUE='"false"'
	SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=print_info VALUE='"true"'
	SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=extruder VALUE={extruder_temp}
	SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=bed VALUE={bed_temp}
	SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=chamber VALUE={chamber_temp}
	SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=chamber_delta VALUE={delta_c}
	{% if extra_soak == 'true' and ena_chamber != 'none' %}
	   SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=soak_tval_c VALUE={chamber_soak}
	{% else %}
	  SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=soak_tval_c VALUE=0
	{% endif %}
	SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=prime_height VALUE={p_height}
	SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=z_adjust VALUE={adjust_z}
	#############  Get filament runout info  #############
	{% if ena_runout == 'switch' %}
	  {% if printer['filament_switch_sensor runout'].enabled|lower == 'true' %}
	    {% set filament_detected = printer['filament_switch_sensor runout'].filament_detected|lower %}
	  {% elif 'virtual_sdcard' in printer and filament_loaded in printer.save_variables.variables %}
	    {% set filament_detected = printer.save_variables.variables.filament_loaded %}
	  {% else %}
	    {% set filament_detected = 'true' %}
	  {% endif %}
	{% elif ena_runout == 'motion' %}
	  {% if printer['filament_motion_sensor runout'].enabled|lower == 'true' %}
	    {% set filament_detected = printer['filament_motion_sensor runout'].filament_detected|lower %}
	  {% elif 'virtual_sdcard' in printer and filament_loaded in printer.save_variables.variables %}
	    {% set filament_detected = printer.save_variables.variables.filament_loaded %}
	  {% else %}
	    {% set filament_detected = 'true' %}
	  {% endif %}
	{% elif ena_runout == 'file' %}
	  {% set filament_detected = printer.save_variables.variables.filament_loaded %}
	{% else %}
	  {% set filament_detected = 'true' %}
	{% endif %}
	#############  Definition done  #############
	_RUNOUT_INFO
	{% if filament_detected == 'true' %}
	  {% if ena_auto_z_offset == 'flexplate' %} _DISPLAY_PLATE {% endif %}
	  {% if ena_relay == 'true' %} _HEATER_ON {% endif %}
	  {% if ena_caselight == 'true' %} _CASELIGHT_ON {% endif %}
	  {% if ena_neo == 'true' %} _LCD_KNOB COLOR=RED BLINK=1  {% endif %}
	  {% if ena_chamber == 'fan' %} M141 S0  {% endif %}   ; exhaust fan off
	  {% if ena_filter == 'true' %} _FILTER_ON {% endif %} ; activate filter
	  _CG28                                                ; home if needed
	  # Move to Middle
	  G90
	  G0 Z{park_pos[2]} F1800                 ; move nozzle to z high first
	  G0 X{park_pos[0]} Y{park_pos[1]} F18000 ; home to get toolhead in the middle
	  # check if soak time is 0 or if the bed is still hot
	  {% if (soak <= 0) or (actBed >= targetBed) %}
	    M117 Heating Extruder
	    {% if (soak <= 0) %}
	      _PRINT_AR T="{"Bed temp: act %3dC min %3dC (target(%3dC) - delta(%dC)) heat soak disabled" % (actBed,targetBed,bed_temp,delta_b)}"
	    {% else %}
	      _PRINT_AR T="{"Bed temp: act %3dC min %3dC (target(%3dC) - delta(%dC)) heat soak not needed" % (actBed,targetBed,bed_temp,delta_b)}"
	    {% endif %}
	    SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=redo_qgl VALUE='"false"'
	    M140 S{bed_temp}      ; heat bed
	    M109 S{extruder_temp} ; heat extruder and wait
	    M190 S{bed_temp}      ; heat bed and wait
	    M400                  ; wait for buffer to clear
	    PAUSE_BASE
	    # go to chamber soak wait
	    SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=state VALUE='"Chamber"'
	    UPDATE_DELAYED_GCODE ID=_START_PRINT_WAIT DURATION=0.1
	  {% else %}
	    M117 Heating Bed
	    _PRINT_AR T="{"Bed temp: act %3dC min %3dC (target(%3dC) - delta(%dC)) heat soak needed" % (actBed,targetBed,bed_temp,delta_b)}"
	    _PRINT_AR T="{"Set Bed temp to %3dC instead of %3dC for faster heat soak" % (bed_soak_temp,bed_temp)}"
	    SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=redo_qgl VALUE='"true"'
	    M106 S90              ; switch part cooling ~35% to move air in chamber
	    M140 S{bed_soak_temp} ; heat bed
	    M400                  ; wait for buffer to clear
	    PAUSE_BASE
	    # Call the wait macro the first time
	    SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=state VALUE='"HeatSoak"'
	    _PRINT_TIME TEXT="HEAT SOAK" TIME={soak}
	    {% if soak > soak_ival %}
	      # soak time is bigger than interval 
	      SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=soak_tval VALUE={soak - soak_ival}
	      UPDATE_DELAYED_GCODE ID=_START_PRINT_WAIT DURATION={soak_ival}
	    {% else %}
	      # soak time is smaller than interval
	      SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=soak_tval VALUE=0
	      UPDATE_DELAYED_GCODE ID=_START_PRINT_WAIT DURATION={soak}
	    {% endif %}
	  {% endif%}    
	{% else %}
	  _PRINT_AR T="No Filament loaded, print canceled!"
	  CANCEL_PRINT_BASE
	  UPDATE_DELAYED_GCODE ID=_DELAY_SDCARD_RESET_FILE DURATION=10
	{% endif%}
      ## Heatsoak Phase call the delay macro until time is over
      {% elif state == 'HeatSoak' %}
	# switch on extruder at _USER_VARIABLE.print_start_extruder_time
	{% if (soak_tval) <= extuder_start_time + (extruder) - 240  %}
	  {%if extruder != printer.extruder.target|int %}
	    M104 S{extruder} ; heat extruder
	  {% endif %}
	{% endif %}
	# switch bed to first layer temp at _USER_VARIABLE.print_start_bed_time 
	{% if (soak_tval) <= bed_reduce_time  %}
	  {% if bed != printer.heater_bed.target|int %}
	    M140 S{bed} ; heat bed
	  {% endif %}
	{% endif %}
	# check remaining time 
	{% if soak_tval > 0 %}
	  # check if interval is bigger than remaining time
	  {% if soak_ival >= soak_tval %}
	    # run last loop with time
	    SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=soak_tval VALUE=0
	    UPDATE_DELAYED_GCODE ID=_START_PRINT_WAIT DURATION={soak_tval}
	  {% else %}
	    ## reduce time by interval
	    SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=soak_tval VALUE={soak_tval - soak_ival}
	    UPDATE_DELAYED_GCODE ID=_START_PRINT_WAIT DURATION={soak_ival}
	  {% endif %}
	{% else %}
	  # go to chamber soak wait
	  SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=state VALUE='"Chamber"'
	  UPDATE_DELAYED_GCODE ID=_START_PRINT_WAIT DURATION=0.1
	  _PRINT_AR T="{"Bed act temp=%3dC heat soak done" % (actBed|int)}"
	{% endif %}
      {% elif state == 'Chamber' %}
	{% set chamber_target = chamber - chamber_delta %}
	{% if ena_chamber == 'fan' %}
	  {% set chamber_act = printer['temperature_fan chamber'].temperature|int %}
	{% elif ena_chamber == 'sensor' %}
	  {% set chamber_act = printer['temperature_sensor chamber'].temperature|int %}
	{% else %}
	  {% set chamber_act = 0 %}
	{% endif %}
	# check remaining time and temp difference 
	{% if (soak_tval_c > 0) and (chamber_act|int < chamber_target|int) %}
	  {% if print_info == 'true' %}
	    SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=print_info VALUE='"false"'
	    _PRINT_AR T="{"Chamber temp: act %3dC min %3dC (target(%2dC) - delta(%dC)) heat soak needed" % (chamber_act,chamber_target, chamber, chamber_delta)}"
	    _PRINT_TIME TEXT="CHAMBER" TIME={soak_tval_c}
	  {% endif %}
	  # check if interval is bigger than remaining time
	  {% if soak_ival >= soak_tval_c %}
	    ## last loop 
	    SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=soak_tval_c VALUE=0
	    UPDATE_DELAYED_GCODE ID=_START_PRINT_WAIT DURATION={soak_tval_c}
	  {% else %}
	    ## reduce time by interval
	    SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=soak_tval_c VALUE={soak_tval_c - soak_ival}
	    UPDATE_DELAYED_GCODE ID=_START_PRINT_WAIT DURATION={soak_ival}
	  {% endif %}
	{% else %}
	  {% if soak_tval_c == 0 %}
	    {% if print_info == 'true' %}
	      _PRINT_AR T="{"Chamber temp: act %3dC min %3dC (target(%2dC) - delta(%dC)) heat soak disabled" % (chamber_act,chamber_target, chamber, chamber_delta)}"
	    {% else %}
	      _PRINT_AR T="{"Chamber temp: act %3dC min %3dC (target(%2dC) - delta(%dC)) heat soak timed out" % (chamber_act,chamber_target, chamber, chamber_delta)}"
	     {% endif %}
	  {% else %}
	    {% if print_info == 'true' %}
	      _PRINT_AR T="{"Chamber temp: act %3dC min %3dC (target(%2dC) - delta(%dC)) heat soak not needed" % (chamber_act,chamber_target, chamber, chamber_delta)}"
	    {% else %}
	      _PRINT_AR T="{"Chamber temp: act %3dC min %3dC (target(%2dC) - delta(%dC)) heat soak temp reached" % (chamber_act,chamber_target, chamber, chamber_delta)}"
	    {% endif %} 
	  {% endif %}
	  SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=state VALUE='"Final"'
	  UPDATE_DELAYED_GCODE ID=_START_PRINT_WAIT DURATION=0.1
	{% endif %}
      ## all whats need to run at the end
      {% elif state == 'Final' %}
	RESUME_BASE
	# set status back to prepare for the next run 
	SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=state VALUE='"Prepare"'     
	{% if ena_neo == 'true' %} _LCD_KNOB COLOR=RED  {% endif %}
	M106 S0                                                   ; turn off part cooling fan
	G21                                                       ; set units to millimeters
	G32                                                       ; home & QGL
	{% if ena_chamber == 'fan' %} M141 S{chamber} {% endif %} ; set target temp for exhaust fan
	NOZZLECLEAN
	G28 Z                                                     ; home Z with clean nozzle
	G0 x400
	{% if ena_auto_z_offset == 'z_calib' %} CALIBRATE_Z {% endif %}
	SET_GCODE_OFFSET Z_ADJUST={z_adjust} MOVE=1
	_PRINT_OFFSET
	{% if prime_height > 0 %}
	  PRIME_LINE PRIME_HEIGHT={prime_height}
	  #PRIME_BALL
	{% else %}
	  #PRIME_BALL
	  PRIME_LINE
	{% endif %}
	{% if 'temperature_sensor endstop' in printer.configfile.settings %}
	  SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=endstop VALUE={printer['temperature_sensor endstop'].temperature}
	{% endif %}
	G90                                                       ; use absolute coordinates
	;M83                                                       ; use relative distances for extrusion
	UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=1
      {% endif %}

    # This is called every PRINT_START intervale 
    # This is needed to stop PRINT_START using CANCEL_PRINT
    [delayed_gcode _START_PRINT_WAIT]
    gcode:
      # Print remaining time
      {% if printer['gcode_macro PRINT_START'].state == 'HeatSoak' %}
	{% set tval = printer['gcode_macro PRINT_START'].soak_tval %}
	_PRINT_TIME TEXT="HEAT SOAK" TIME={tval|int}
      {% elif printer['gcode_macro PRINT_START'].state == 'Chamber' %}
	{% set tval = printer['gcode_macro PRINT_START'].soak_tval_c %}
	_PRINT_TIME TEXT="SOAK" TIME={tval|int}
      {% endif %}
      # Check CANCLE_PRINT was executed
      {% if printer['gcode_macro CANCEL_PRINT'].execute == 'false' %}
	PRINT_START  ; Junp back to PRINT_START
      {% else %}
	# break loop
	# insure state is correct for the next print start
	SET_GCODE_VARIABLE MACRO=CANCEL_PRINT VARIABLE=execute VALUE='"false"'
	SET_GCODE_VARIABLE MACRO=PRINT_START VARIABLE=state VALUE='"Prepare"'
	UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=1
      {% endif %}
#+END_SRC
  
*** Print End
#+BEGIN_SRC conf
[gcode_macro PRINT_END]
description: All commands after the print
gcode:
  SAVE_GCODE_STATE NAME=STATE_PRINT_END
  ##### Get Boundaries #####
  {% set max_x = printer.toolhead.axis_maximum.x|float %}
  {% set max_y = printer.toolhead.axis_maximum.y|float %}
  {% set max_z = printer.toolhead.axis_maximum.z|float %}
  {% set act_x = printer.toolhead.position.x|float %}
  {% set act_y = printer.toolhead.position.y|float %}
  {% set act_z = printer.toolhead.position.z|float %}
  ##### Get user defines #####
  {% set purge_pos = printer['gcode_macro _USER_VARIABLE'].purge %}
  {% set vent_on = printer['gcode_macro _USER_VARIABLE'].vent_on|int %}
  {% set retreact = printer['gcode_macro _USER_VARIABLE'].retreact_end|float * -1 %}
  {% set fan_off = printer['gcode_macro _USER_VARIABLE'].fan_run_after_print|int * 60 %}
  {% set vent_off = printer['gcode_macro _USER_VARIABLE'].fan_run_after_print|int * 60 + 5 %}
  #############  Get hardware enables  #############
  {% set ena_neo = printer['gcode_macro _USER_VARIABLE'].neo_display|lower %}
  {% set ena_chamber = printer['gcode_macro _USER_VARIABLE'].chamber|lower %}
  {% set ena_caselight = printer['gcode_macro _USER_VARIABLE'].caselight|lower %}
  {% set ena_filter = printer['gcode_macro _USER_VARIABLE'].filter|lower %}
  {% set ena_unload_sd = printer['gcode_macro _USER_VARIABLE'].print_end_unload_sd|lower %}
  ##### Calculate save move #####
  {% if act_x < (max_x - 20.0) %}
    {% set x_safe = 20.0 %}
  {% else %}
    {% set x_safe = -20.0 %}
  {% endif %}
  {% if act_y < (max_y - 20.0) %}
    {% set y_safe = 20.0 %}
  {% else %}
    {% set y_safe = -20.0 %}
  {% endif %}
  {% if act_z < (max_z - 2.0) %}
    {% set z_safe = 2.0 %}
  {% else %}
    {% set z_safe = max_z - act_z %}
  {% endif %}
  ##### end of definitions #####
  M400                                                      ; wait for buffer to clear
  G92 E0                                                    ; zero the extruder
  M83                                                       ; relative extrusion
  G1 E{retreact} F1800                                      ; retract filament
  G91                                                       ; relative positioning
  G0 X{x_safe} Y{y_safe} Z{z_safe} F20000                   ; move nozzle to remove stringing
  TURN_OFF_HEATERS                                          ; turn off heaters
  M107                                                      ; turn off fan
  {% if ena_chamber == 'fan' %} M141 S{vent_on} {% endif %} ; vent chamber (setting fan to below ambient)
  G90                                                       ; absolute positioning
  G0 X{purge_pos[0]} Y{purge_pos[1]} F18000                 ; park nozzle at brush bin
  _ADD_PRINT_TIME
  _SD_PRINT_STATS R='done'
  _SD_PRINTER_STATS
  {% if ena_neo == 'true' %} _LCD_KNOB COLOR=GREEN {% endif %}
  {% if ena_chamber == 'fan' %} UPDATE_DELAYED_GCODE ID=_DELAY_VENT_OFF DURATION={vent_off} {% endif %}
  {% if ena_filter == 'true' %} UPDATE_DELAYED_GCODE ID=_DELAY_FILTER_OFF DURATION={fan_off} {% endif %}
  {% if 'temperature_sensor endstop' in printer.configfile.settings %}
    _PRINT_ENDSTOP_TEMP
  {% endif %}
  {% if ena_unload_sd == 'true' %} UPDATE_DELAYED_GCODE ID=_DELAY_SDCARD_RESET_FILE DURATION=10 {% endif %}
  UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=10
  RESTORE_GCODE_STATE NAME=STATE_PRINT_END
  #####  set speed and extruder factor to default  #####
  M220 S100
  M221 S100

#+END_SRC

*** Other
#+BEGIN_SRC conf
[gcode_macro G32]
description: Execute plate offset and QGL
gcode:
  #############  Get hardware enables  #############
  {% set ena_auto_z_offset = printer['gcode_macro _USER_VARIABLE'].auto_z_offset|lower %}
  #############  END of defines  #############
  _PRINT_AR T="Home & QGL" SHOW_LCD=true
  _CG28 ; home if not already homed
  BED_MESH_CLEAR
  ## flexplate must be excluded if switching to z_calibration
  {% if ena_auto_z_offset == 'z_calib' %} SET_GCODE_OFFSET Z=0
  {% elif ena_auto_z_offset == 'flexplate' %} _SET_PLATE_OFFSET {% endif %}
  ## check if QGL was already executed
  ## variable redo_qgl will always force a QGL
  {% if printer['gcode_macro PRINT_START'].redo_qgl == 'true' %}
    _PRINT_AR T="QGL forced by PRINT_START"
    QUAD_GANTRY_LEVEL PARK=false
  {% else %} 
    ## if no QGL was done until now
    {% if printer.quad_gantry_level.applied|lower == 'false' %}
      _PRINT_AR T="QGL not executed yet"
      QUAD_GANTRY_LEVEL PARK=false
    {% endif %}
  {% endif %}
  UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=1

[gcode_macro M204]
description: Set and limit acceleration to cfg value
rename_existing: M204.1
gcode:
  #####  get accel from parameter  #####
  {% if 'S' in params and params.S|float > 0 %}
      {% set param_accel = params.S|float %}
  {% elif 'P' in params and 'T' in params and params.P|float > 0 and params.T|float > 0 %}
    {% if params.P|float > params.T|float %}    
      {% set param_accel = params.T|float %}
    {% else %}
      {% set param_accel = params.P|float %}
    {% endif %}
  {% endif %}
  #####  get limits from config  #####
  {% set max_accel = printer.configfile.settings.printer.max_accel|float %}
  {% set max_accel_to_decel = printer.configfile.settings.printer.max_accel_to_decel|float %}
  #####  end of definition  #####
  {% if param_accel is defined %}  
    #####  calc accel_to deccel  #####
    {% set param_accel_to_decel = (param_accel / 2.0) %}
    #####  limit values to config values  ##### 
    {% if param_accel < max_accel %}
      {% set accel = param_accel %}
    {% else %}
      {% set accel = max_accel %}
    {% endif %}
    {% if param_accel_to_decel < max_accel_to_decel %}
      {% set accel_to_decel = param_accel_to_decel %}
    {% else %}
      {% set accel_to_decel = max_accel_to_decel %}
    {% endif %}
    #####  set value  #####
    SET_VELOCITY_LIMIT ACCEL={accel} ACCEL_TO_DECEL={accel_to_decel}
  {% else %}
    {% set get_params = [] %}
    {% for key in params %}
      {% if key is not in ['M'] %}
        {% set get_params = get_params.append(key + params[key]) %}
      {% endif %}
    {% endfor %}
    {action_respond_info("Invalid M204 command \"M204 %s\"" % get_params|join(" "))}
  {% endif %}
  
[gcode_macro M900]
description: Set pressure advance
gcode:
  SET_PRESSURE_ADVANCE ADVANCE={params.K|default(0)}

## print Offsets defined by user and/or calibrate_z    z_calib flexplate
[gcode_macro _PRINT_OFFSET]
description: Print gcode offsets defined by script or user in PRINT_START
gcode:
  {% set user_z_adjust = printer['gcode_macro PRINT_START'].z_adjust|default(0.0) %}
  {% set z_calib_z_adjust = printer.z_calibration.last_z_offset|default(0.0) %}
  {% set act_z_adjust = printer.gcode_move.homing_origin.z %}
  {% set ena_auto_z_offset = printer['gcode_macro _USER_VARIABLE'].auto_z_offset|lower %}
  {% if ena_auto_z_offset == 'z_calib' %} 
     {action_respond_info("GCODE OFFSET for Z applied from:
                           User %.3f
                           CALIBRATE_Z %.3f
                           Actual total %.3f" % (user_z_adjust,z_calib_z_adjust,act_z_adjust))}
  {% else %}
    {action_respond_info("GCODE OFFSET for Z applied from:
                          User %.3f
                          Actual total %.3f" % (user_z_adjust,act_z_adjust))}
  {% endif %}
    
## print endstop temperature used only by PRINT_END
[gcode_macro _PRINT_ENDSTOP_TEMP]
description: Print endstop temp for start and end print
gcode:
  {% set endstop_start = printer['gcode_macro PRINT_START'].endstop %}
  {% set endstop_end = printer['temperature_sensor endstop'].temperature %}
  {% if 'temperature_sensor bed' in printer %}
    {% set actBed = printer['temperature_sensor bed'].temperature %}
  {% else %}
    {% set actBed = printer.heater_bed.temperature %}
  {% endif %}
  {action_respond_info("PRINT_END
                        BED temp: act %3.2fC
                        Endstop temp: start %2.2fC end %2.2fC" % (actBed, endstop_start, endstop_end))}

## print time value used only by PRINT_START
[gcode_macro _PRINT_TIME]
description: Helper: Print time for start macro
gcode:
  #####  set defaults  #####
  {% set text = params.TEXT|default('Timer') %}
  {% set show_ar = params.SHOW_AR|default('false') %}
  #####  calc values for time  #####
  {% set minutes = ((params.TIME|int / 60) % 60)|int %}
  {% set seconds = (params.TIME|int % 60)|int %}
  M117 {'%s' % (TEXT)} {minutes|int}:{'%02d' % (seconds|int)}
  {%if show_ar == 'true' %}
    {action_respond_info("%s %d:%02d" % (text,minutes|int,seconds|int))}
  {% endif %}
#+END_SRC
** Web Client Macros (Pause, Resume, Cancel)

#+BEGIN_SRC conf
[pause_resume]

[display_status]

[respond]
default_type: echo
#   Sets the default prefix of the "M118" and "RESPOND" output to one
#   of the following:
#       echo: "echo: " (This is the default)
#       command: "// "
#       error: "!! "
#default_prefix: echo:
#   Directly sets the default prefix. If present, this value will
#   override the "default_type".

#####################################################################
#  Macros
#####################################################################
[gcode_macro CANCEL_PRINT]
description: Cancel the actual running print
rename_existing: CANCEL_PRINT_BASE
variable_execute: 'false'
gcode:
  ##### Get params and default #####
  {% set park = params.PARK|default(0)|int %}
  {% set error = params.ERROR|default(0)|int %}
  ##### Get user defines #####
  {% set park_pos = printer['gcode_macro _USER_VARIABLE'].park_bed %}
  {% set add_temp = printer["gcode_macro _USER_VARIABLE"].extruder_min_add|int %}
  {% set vent_on = printer["gcode_macro _USER_VARIABLE"].vent_on|int %}
  {% set retreact = printer["gcode_macro _USER_VARIABLE"].retract_cancel|float * -1 %}
  {% set fan_off = printer['gcode_macro _USER_VARIABLE'].fan_run_after_print|int * 60 %}
  {% set vent_off = printer['gcode_macro _USER_VARIABLE'].fan_run_after_print|int * 60 + 5 %}
  ##### Get hardware enables #####
  {% set ena_neo = printer['gcode_macro _USER_VARIABLE'].neo_display|lower %}
  {% set ena_chamber = printer['gcode_macro _USER_VARIABLE'].chamber|lower %}
  {% set ena_caselight = printer['gcode_macro _USER_VARIABLE'].caselight|lower %}
  {% set ena_filter = printer['gcode_macro _USER_VARIABLE'].filter|lower %}
  {% set ena_unload_sd = printer['gcode_macro _USER_VARIABLE'].print_end_unload_sd|lower %}
  ##### store min and current extrution temp in variable ##### 
  {% set extruder_min = printer.configfile.config.extruder.min_extrude_temp|int + add_temp %}
  ##### end of definitions #####
  SET_GCODE_VARIABLE MACRO=CANCEL_PRINT VARIABLE=execute VALUE='"true"'
  M117 Cancel
  CANCEL_PRINT_BASE
  {% if printer.extruder.can_extrude|lower == 'false' %}
      {action_respond_info("Extruder Temp to low heat to %2dC" % extruder_min)}
      M109 S{extruder_min}                                  ; heat extruder and wait
  {% endif %}
  M83
  G1 E{retreact} F1800
  TURN_OFF_HEATERS                                          ; turn off heaters
  {% if park == 1 %}
    G90
    G0 Z{park_pos[2]} F1800                                 ; move nozzle to z high first
    G0 X{park_pos[0]} Y{park_pos[1]} F18000                 ; home to get toolhead in the middle
  {% endif %}
  M107                                                      ; turn off fan
  {% if ena_chamber == 'fan' %} M141 S{vent_on} {% endif %} ; vent chamber (setting fan to below ambient)
  _ADD_PRINT_TIME
  {% if error == 1 %}
    {% if ena_neo == 'true' %} _LCD_KNOB COLOR=RED BLINK=0.2 {% endif %}
    _SD_PRINT_STATS R='abort'
  {% else %}
   {% if ena_neo == 'true' %} _LCD_KNOB COLOR=BLUE {% endif %}
    _SD_PRINT_STATS R='canceled'
  {% endif %}
  _SD_PRINTER_STATS
  {% if ena_chamber == 'fan' %} UPDATE_DELAYED_GCODE ID=_DELAY_VENT_OFF DURATION={vent_off} {% endif %}
  {% if ena_filter == 'true' %} UPDATE_DELAYED_GCODE ID=_DELAY_FILTER_OFF DURATION={fan_off} {% endif %}
  {% if ena_unload_sd == 'true' %} UPDATE_DELAYED_GCODE ID=_DELAY_SDCARD_RESET_FILE DURATION=10 {% endif %}
  UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=10

[gcode_macro PAUSE]
description: Pause the actual running print
rename_existing: PAUSE_BASE
gcode:
  ##### Get user defines #####
  {% set add_temp = printer["gcode_macro _USER_VARIABLE"].extruder_min_add|int %}
  {% set retract = printer["gcode_macro _USER_VARIABLE"].retract_pause|float * -1 %}
  {% set purge_pos = printer["gcode_macro _USER_VARIABLE"].purge %}
  ##### store min and current extrution temp in variable ##### 
  {% set extruder_min = printer.configfile.config.extruder.min_extrude_temp|int + add_temp %}
  {% set extruder_target = printer.extruder.target %}
  ##### either use brush bin position or user defined ##### 
  {% set x_park = params.X|default(purge_pos[0]) %}
  {% set y_park = params.Y|default(purge_pos[1]) %}
  ##### calculate save lift position #####
  {% set max_z = printer.toolhead.axis_maximum.z|float %}
  {% set act_z = printer.toolhead.position.z|float %}
  {% if act_z < (max_z - 2.0) %}
    {% set z_safe = 2.0 %}
  {% else %}
    {% set z_safe = max_z - act_z %}
  {% endif %}
  ##### end of definitions #####
  ##### added because of motion sensor #####
  ## not sure why but sometime it generate an runout event while heatsoak  
  {% if printer.extruder.can_extrude|lower == 'false' %}
      {action_respond_info("Extruder Temp to low heat to %2dC" % extruder_min)}
      M109 S{extruder_min} ; heat extruder and wait
  {% endif %}
  ##### added because of motion sensor ##### 
  {% if ena_neo == 'true' %} _LCD_KNOB COLOR=BLUE BLINK=1 {% endif %}
  M117 Pause
  PAUSE_BASE
  G91
  G1 E{retract} F1800
  G1 Z{z_safe} F900
  G90
  G1 X{x_park} Y{y_park} F18000 ; park nozzle at brush bin or user defined
  # restore old extruder temperature
  M109 S{extruder_target}
  UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=10

[gcode_macro RESUME]
description: Resume the actual running print
rename_existing: RESUME_BASE
gcode:
  ##### Get user defines #####
  {% set add_temp = printer["gcode_macro _USER_VARIABLE"].extruder_min_add|int %}
  {% set extrude = printer["gcode_macro _USER_VARIABLE"].retract_pause %}
  ##### store min and current extrution temp in variable ##### 
  {% set extruder_min = printer.configfile.config.extruder.min_extrude_temp|int + add_temp %}
  {% set extruder_target = printer.extruder.target %}
  #### get VELOCITY parameter if specified ####
  {% if 'VELOCITY' in params|upper %}
    {% set get_params = ('VELOCITY=' + params.VELOCITY)  %}
  {%else %}
    {% set get_params = "" %}
  {% endif %}
  ##### end of definitions #####
  {% if ena_neo == 'true' %} _LCD_KNOB COLOR=RED {% endif %}
  M117 Printing
  {% if printer.extruder.can_extrude|lower == 'false' %}
      {action_respond_info("Extruder Temp to low heat to %2dC" % extruder_min)}
      M109 S{extruder_min} ; heat extruder and wait
  {% endif %}
  G91
  G1 E{extrude} F2100
  # restore old extruder temperature
  M109 S{extruder_target}
  RESUME_BASE {get_params}
  UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=10
#+END_SRC

*** Display Menu Stuff
COMMENTED_OUT
##+BEGIN_SRC conf
#####################################################################
#                 LCD menu that works with mainsail                 #
#####################################################################
#   Main
#   ...
#   + SD Card
#       + Show loaded file
#       + Load File (only if not printing and no file loaded)
#       + Unload File (only if not printing and a file is loaded)
#       + Start printing (only if not printing and a file is loaded)
#       + Pause printing (only while printing)
#       + Resume printing (only while paused)
#       + Cancel printing (only while paused)

# [menu __main __sdcard]
# type: list
# enable: {'virtual_sdcard' in printer}
# name: SD Card

# [menu __main __sdcard __file]
# type: command
# name: File: {printer.print_stats.filename}
# index: 0

# [menu __main __sdcard __load]
# type: vsdlist
# #type: list
# #event_sender: __vsdfiles
# enable: {not printer.virtual_sdcard.file_path and not (printer.print_stats.state == "printing" or printer.print_stats.state == "paused")}
# name: Load file
# index: 1

# [menu __main __sdcard __unload]
# type: command
# enable: {printer.virtual_sdcard.file_path and not (printer.print_stats.state == "printing" or printer.print_stats.state == "paused")}
# name: Unload file
# index: 2
# gcode:
#   # back is needed to reload the modified menu structure
#   {menu.back()}
#   SDCARD_RESET_FILE

# [menu __main __sdcard __start]
# type: command
# enable: {printer.virtual_sdcard.file_path and not (printer.print_stats.state == "printing" or printer.print_stats.state == "paused")}
# name: Start print
# index: 3
# gcode:
#   {menu.exit()}
#   UPDATE_DELAYED_GCODE ID=_LCD_INIT_OFF DURATION=10
#   M24

# [menu __main __sdcard __pause]
# type: command
# enable: {printer.print_stats.state == "printing"}
# name: Pause print
# gcode:
#   # back is needed to reload the modified menu structure
#   {menu.back()}
#   PAUSE

# [menu __main __sdcard __resume]
# type: command
# enable: {printer.print_stats.state == "paused"}
# name: Resume print
# gcode:
#   {menu.exit()}
#   UPDATE_DELAYED_GCODE ID=_LCD_INIT_OFF DURATION=10
#   RESUME

# [menu __main __sdcard __cancel]
# type: command
# enable: {printer.print_stats.state == "paused"}
# name: Cancel print
# gcode:
#   {menu.exit()}
#   UPDATE_DELAYED_GCODE ID=_LCD_INIT_OFF DURATION=10
#   CANCEL_PRINT
#+END_SRC
** Print Time Macros
#+BEGIN_SRC conf
#####################################################################
# 	Macro
#####################################################################
## This macro stores the variables
## must be added to PRINT_END - CANCEL_PRINT Macro 
## works only with the use of virtual sd card!
[gcode_macro _ADD_PRINT_TIME]
description: Helper: Store print time values in variables
gcode:
  ##### get saved values or initiate if not exist #####
  {% if not printer.save_variables.variables.totalprintingtime %}
    {% set totaltime = 0 %} 
  {% else %}
    {% set totaltime = printer.save_variables.variables.totalprintingtime %}
  {% endif %}
  {% if not printer.save_variables.variables.lastservicetime %}
    {% set lastservice = 0 %} 
  {% else %}
    {% set lastservice = printer.save_variables.variables.lastservicetime %}
  {% endif %}
  {% if not printer.save_variables.variables.filament_used %}
    {% set filament = 0.0 %}
  {% else %}
    {% set filament = printer.save_variables.variables.filament_used|float %}
  {% endif %}
  {% if not printer.save_variables.variables.filterusetime %}
    {% set filteruse = 0.0 %}
  {% else %}
    {% set filteruse = printer.save_variables.variables.filterusetime|float %}
  {% endif %}
  ##### get values of current print #####
  {% set currenttime = printer.print_stats.total_duration %}
  {% set currentprint = printer.print_stats.filament_used|float %}
  ##### Save new values #####
  SAVE_VARIABLE VARIABLE=totalprintingtime VALUE={(totaltime + currenttime)|int}
  SAVE_VARIABLE VARIABLE=lastservicetime VALUE={(lastservice + currenttime)|int}
  SAVE_VARIABLE VARIABLE=filterusetime VALUE={(filteruse + currenttime)|int}
  SAVE_VARIABLE VARIABLE=filament_used VALUE={(filament + currentprint)|float}
  _DISPLAY_PRINT_TIME PREFIX=Took SECONDS={currenttime}

[gcode_macro _DISPLAY_PRINT_TIME]
description: Helper: Print actual stored print time
gcode:
  # set default parameter value
  {% set totaltime = params.SECONDS|default(-1)|int %}
  {% set prefix = params.PREFIX|default(Total) %}
  {% if totaltime == -1 %}
    {% set totaltime = printer.save_variables.variables.totalprintingtime %}
  {% endif %}
  {% set hours = (totaltime / 3600)|int %}
  {% set minutes = ((totaltime / 60) % 60)|int %}
  {% set seconds = (totaltime % 60)|int %}
  {action_respond_info("Print time %s %d:%02d:%02d" % (prefix|string,hours|int,minutes|int,seconds|int))}
  M117 {prefix} {hours}:{'%02d' % (minutes|int)}:{'%02d' % (seconds|int)}
  UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=10

[gcode_macro _SD_PRINT_STATS]
description: Helper: Print statistic of last print
gcode:
  ## output of data of the last print
  ## used at PRINT_END and CANCEL_PRINT
  {% set PT = printer.print_stats.print_duration %}
  {% set Ph = (PT / 3600)|int %}
  {% set Pm = ((PT / 60) % 60)|int %}
  {% set Ps = (PT % 60)|int %}
  {% set TT = printer.print_stats.total_duration %}
  {% set Th = (TT / 3600)|int %}
  {% set Tm = ((TT / 60) % 60)|int %}
  {% set Ts = (TT % 60)|int %}
  {% set Fil = printer.print_stats.filament_used|float / 1000.0 %}
  {action_respond_info("Statistic of last Print (%s):
                        Name: %s
                        Filament: %.4fm
                        Print Time: %d:%02d:%02d
                        Total Time: %d:%02d:%02d" %
  (params.R, printer.print_stats.filename, Fil, Ph|int, Pm|int, Ps|int, Th|int, Tm|int, Ts|int))}
  

[gcode_macro _SD_PRINTER_STATS]
description: Helper: Print statistic of printer
gcode:
  ## output data of the stoared statis
  ## use e.g at PRINT_END and CANCEL_PRINT
  {% set ST= printer.save_variables.variables.lastservicetime %}
  {% set Sh = (ST / 3600)|int %}
  {% set Sm = ((ST / 60) % 60)|int %}
  {% set Ss = (ST % 60)|int %}
  {% set TT = printer.save_variables.variables.totalprintingtime %}
  {% set Th = (TT / 3600)|int %}
  {% set Tm = ((TT / 60) % 60)|int %}
  {% set Ts = (TT % 60)|int %}
  {% set FT = printer.save_variables.variables.filterusetime %}
  {% set Fh = (FT / 3600)|int %}
  {% set Fm = ((FT / 60) % 60)|int %}
  {% set Fs = (FT % 60)|int %}
  {% set Fil = printer.save_variables.variables.filament_used|float / 1000.0 %}
  {action_respond_info("Printer Statistics:
                        Total Print Time: %d:%02d:%02d
                        Total Filament used: %.4fm
                        Filter use time: %d:%02d:%02d
                        Time since last Service: %d:%02d:%02d" %
  (Th|int, Tm|int, Ts|int, Fil, Fh|int, Fm|int, Fs|int, Sh|int, Sm|int, Ss|int))}
  {% if printer['gcode_macro _USER_VARIABLE'].filter|lower == 'true' %} 
    UPDATE_DELAYED_GCODE ID=_CHECK_FILTER DURATION=1
  {% endif %}
  
[delayed_gcode _CHECK_FILTER]
initial_duration: 5
gcode:
  {% if printer['gcode_macro _USER_VARIABLE'].filter|lower == 'true' %}
    ## Micro need exchange every 80h
    {% set Fh = (printer.save_variables.variables.filterusetime / 3600)|int %}
    {% if Fh|int >= printer['gcode_macro _USER_VARIABLE'].filter_use_time|int %}
      M117 Change Filter!
      {action_respond_info("Change Filter material at Micro!")}
      UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=10
    {% endif %}
  {% endif %}  
  
[gcode_macro RST_FILTER]
description: Reset Nevermore interval time
gcode:
  SAVE_VARIABLE VARIABLE=filterusetime VALUE=0
  {action_respond_info("Flter used time reseted to zero")}
  
[gcode_macro RST_SERVICE]
description: Reset Service interval time
gcode:
  SAVE_VARIABLE VARIABLE=lastservicetime VALUE=0
  {action_respond_info("Time since last service reseted to zero")}
#+END_SRC

*** Display Menu Stuff  
#+BEGIN_SRC conf
### klipper display menu statistic ###
# [menu __main __statistic]
# type: list
# enable: {not printer.idle_timeout.state == "Printing" and 'save_variables' in printer}
# name: Satistic

# [menu __main __statistic __totaltime]
# type: command
# enable: True
# name: Time of Operation
# gcode:
#   {menu.exit()}
#   _DISPLAY_PRINT_TIME PREFIX=Total SECONDS={printer.save_variables.variables.totalprintingtime}
#   UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=10
  
# [menu __main __statistic __filament]
# type: command
# enable: True
# name: Total Filament used
# gcode:
#   {menu.exit()}
#   M117 Filerment {'%.4f' % (printer.print_stats.filament_used|float / 1000.0)}m
#   {action_respond_info("Total Filament printed: %.4fm" % (printer.print_stats.filament_used|float / 1000.0))}
#   UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=10

# [menu __main __statistic __filtertime]
# type: command
# enable: True
# name: Time since Filter change
# gcode:
#   {menu.exit()}
#   _DISPLAY_PRINT_TIME PREFIX=Filter SECONDS={printer.save_variables.variables.filterusetime}
#   UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=10

# [menu __main __statistic __servicetime]
# type: command
# enable: True
# name: Time since Service
# gcode:
#   {menu.exit()}
#   _DISPLAY_PRINT_TIME PREFIX=Service SECONDS={printer.save_variables.variables.lastservicetime}
#   UPDATE_DELAYED_GCODE ID=_CLEAR_DISPLAY DURATION=10
  
  
# [menu __main __statistic __rst_filter]
# type: command
# enable: True
# name: Reset Filter time
# gcode:
#   {menu.exit()}
#   RST_FILTER

    
# [menu __main __statistic __rst_service]
# type: command
# enable: True
# name: Reset Service time
# gcode:
#   {menu.exit()}
#   RST_SERVICE

    
#+END_SRC
** Parking Macros
#+BEGIN_SRC conf
[gcode_macro PARKFRONT]
description: Park head front high
gcode:
  ##### Get user defines #####
  {% set park_pos = printer['gcode_macro _USER_VARIABLE'].park_front %}
  ##### end of definitions #####
  SAVE_GCODE_STATE NAME=STATE_PARK
  _CG28 ; home if not already homed
  G90   ; absolute positioning
  G0 X{park_pos[0]} Y{park_pos[1]} Z{park_pos[2]} F18000
  RESTORE_GCODE_STATE NAME=STATE_PARK
  
[gcode_macro PARKFRONTLOW]
description: Park head front low
gcode:
  ##### Get user defines #####
  {% set park_pos = printer['gcode_macro _USER_VARIABLE'].park_frontlow %}
  ##### end of definitions #####
  SAVE_GCODE_STATE NAME=STATE_PARK
  _CG28 ; home if not already homed
  G90   ; absolute positioning
  G0 X{park_pos[0]} Y{park_pos[1]} Z{park_pos[2]} F18000
  RESTORE_GCODE_STATE NAME=STATE_PARK
   
[gcode_macro PARKREAR]
description: Park head rear high
gcode:
  ##### Get user defines #####
  {% set park_pos = printer['gcode_macro _USER_VARIABLE'].park_rear %}
  ##### end of definitions #####
  SAVE_GCODE_STATE NAME=STATE_PARK
  _CG28 ; home if not already homed
  G90   ; absolute positioning
  G0 X{park_pos[0]} Y{park_pos[1]} Z{park_pos[2]} F18000
  RESTORE_GCODE_STATE NAME=STATE_PARK
   
[gcode_macro PARKCENTER]
description: Park head middle of printer
gcode:
  ##### Get user defines #####
  {% set park_pos = printer['gcode_macro _USER_VARIABLE'].park_center %}
  ##### end of definitions #####
  SAVE_GCODE_STATE NAME=STATE_PARK
  _CG28 ; home if not already homed
  G90   ; absolute positioning
  G0 X{park_pos[0]} Y{park_pos[1]} Z{park_pos[2]} F18000
  RESTORE_GCODE_STATE NAME=STATE_PARK
   
[gcode_macro PARKBED]
description: Park head middle of bed low
gcode:
  ##### Get user defines #####
  {% set park_pos = printer['gcode_macro _USER_VARIABLE'].park_bed %}
  ##### end of definitions #####
  SAVE_GCODE_STATE NAME=STATE_PARK
  _CG28 ; home if not already homed
  G90   ; absolute positioning
  G0 X{park_pos[0]} Y{park_pos[1]} Z{park_pos[2]} F18000
  RESTORE_GCODE_STATE NAME=STATE_PARK
#+END_SRC

*** Display Menu  
COMMENTED_OUT
##+BEGIN_SRC conf
# [menu __main __control __park_pos]
# type: input
# enable: {not printer.idle_timeout.state == "Printing"}
# index: 0
# name: Positon: {['Bed','Center','Rear','Front', FrontLow][menu.input|int]}
# input: 0
# input_min: 0
# input_max: 4
# gcode:
#     {%- if menu.event == 'long_click' -%}
#       {%- if menu.input|int == 1 -%}
#         PARKCENTER
#       {%- elif menu.input|int == 2 -%}
#         PARKREAR
#       {%- elif menu.input|int == 3 -%}
#         PARKFRONT
#       {%- elif menu.input|int == 4 -%}
#         PARKFRONTLOW
#       {%- else -%}
#         PARKBED
#       {%- endif -%}
#     {%- endif -%}
#+END_SRC
** Debug Macros
#+BEGIN_SRC conf
## Use:
##   - DUMP_PARAMETERS
##   - DUMP_PARAMETERS S='gcode_macro _USER_VARIABLE'
[gcode_macro DUMP_PARAMETERS]
description: Debug: Print all entries of the printer object
gcode:
  {% set parameters = [] %}
  {% for name1 in printer|sort %}
    {% if 'S' in params %}
      {% if name1 is in [params.S] %}
        {% for name2 in printer[name1]|sort %}
          {% set parameters = parameters.append("printer['%s'].%s = %s" % (name1, name2, printer[name1][name2])) %}
        {% endfor %}
      {% endif %}
    {% else %}
      {% if name1 is not in ['configfile'] %}
        {% for name2 in printer[name1]|sort %}
          {% set parameters = parameters.append("printer['%s'].%s = %s" % (name1, name2, printer[name1][name2])) %}
        {% endfor %}
      {% endif %}
    {% endif %}
  {% endfor %}
  {action_respond_info(parameters|join("\n"))}

## Use:
##   - DUMP_CONFIG S='printer'
[gcode_macro DUMP_CONFIG]
description: Debug: Print the selected entrie of the printer config object
gcode:
  {% if 'S' in params %}
    {% set parameters = [] %}
    {% for name1 in printer.configfile.config %}
      {% if name1 is in [params.S] %}
        {% for name2 in printer.configfile.config[name1]|sort %}
          {% set parameters = parameters.append("printer.configfile.config['%s'].%s = %s" % (name1, name2, printer.configfile.config[name1][name2])) %}
        {% endfor %}
      {% endif %}
    {% endfor %}
    {action_respond_info(parameters|join("\n"))}
  {% else %}
    {action_respond_info("WARNING: parameter S needed call e.g. DUMP_CONFIG S='printer'")}
  {% endif %}

## Use:
##   - DUMP_WARNINGS
[gcode_macro DUMP_WARNINGS]
description: Debug: Print all warning messages from klipper
gcode:
  {% set parameters = ["printer.configfile.warnings:"] %}
  {% for name1 in printer.configfile.warnings %}
      {% set parameters = parameters.append("%s -> %s -> %s\n%s" % (name1.type, name1.section, name1.option, name1.message)) %}
  {% endfor %}
  {action_respond_info(parameters|join("\n"))}

## Use:
##   - DUMP_SETTINGS S='printer'
[gcode_macro DUMP_SETTINGS]
description: Debug: Print the selected entrie of the printer settings object
gcode:
  {% if 'S' in params %}
    {% set parameters = [] %}
    {% for name1 in printer.configfile.settings %}
      {% if name1 is in [params.S] %}
        {% for name2 in printer.configfile.settings[name1]|sort %}
          {% set parameters = parameters.append("printer.configfile.settings['%s'].%s = %s" % (name1, name2, printer.configfile.settings[name1][name2])) %}
        {% endfor %}
      {% endif %}
    {% endfor %}
    {action_respond_info(parameters|join("\n"))}
  {% else %}
    {action_respond_info("WARNING: parameter S needed call e.g. DUMP_SETTINGS S='printer'")}
  {% endif %}

#####################################################################
#  Macros needed for several debug activities
#####################################################################
#+END_SRC
WEBCLIENT NEXT
** Force Move (When Z Height is Max)
## This is an emergency fix if the gantry is at the max Z position what makes homing imposible
##  1) set enable_force_move: True
##  2) do an klipper restart
##  3) use a SET_KINEMATIC_POSITION e.g SET_KINEMATIC_POSITION X=50 Y=50 Z=100
##     that position does not need to be accurate as we only use it to get the head down
##  4) get the head down by at least the amount you have specified as z lift for homing e.g. 25 mm
##  5) set enable_force_move: False
##  6) do an klipper restart
##  7) now you can home normal again 

## Reference:
##  Force move enabled will allow the following 2 debug commands. !!! Use them carefully !!!
##
##  SET_KINEMATIC_POSITION [X=<value>] [Y=<value>] [Z=<value>]: Force the low-level kinematic code to believe 
##  the toolhead is at the given cartesian position. This is a diagnostic and debugging command; use 
##  SET_GCODE_OFFSET and/or G92 for regular axis transformations. If an axis is not specified then it will 
##  default to the position that the head was last commanded to. Setting an incorrect or invalid position 
##  may lead to internal software errors. This command may invalidate future boundary checks; issue a G28 
##  afterwards to reset the kinematics.
##
##  FORCE_MOVE STEPPER=<config_name> DISTANCE=<value> VELOCITY=<value> [ACCEL=<value>]: This command will 
##  forcibly move the given stepper the given distance (in mm) at the given constant velocity (in mm/s). 
##  If ACCEL is specified and is greater than zero, then the given acceleration (in mm/s^2) will be used; 
##  otherwise no acceleration is performed. If acceleration is not performed then it can lead to the 
##  micro-controller reporting No next step errors (avoid these errors by specifying an ACCEL value or 
##  use a very low VELOCITY). No boundary checks are performed; no kinematic updates are made; other 
##  parallel steppers on an axis will not be moved. Use caution as an incorrect command could cause 
##  damage! Using this command will almost certainly place the low-level kinematics in an incorrect state; 
##  issue a G28 afterwards to reset the kinematics. This command is intended for low-level diagnostics and debugging.
#+BEGIN_SRC conf
[force_move]
enable_force_move: False
#+END_SRC
* Moonraker Power Control
#+BEGIN_SRC conf

[idle_timeout]
gcode:
  {% if printer.webhooks.state|lower == 'ready' %}
    {% if printer.pause_resume.is_paused|lower == 'false' %}
      {action_respond_info("POWER: Execute Idle Timeout")}
      TURN_OFF_HEATERS
      {% if printer['gcode_macro _USER_VARIABLE'].relay|lower == 'true' %}
        UPDATE_DELAYED_GCODE ID=_DELAY_HEATER_OFF DURATION=10
      {% endif %}
      UPDATE_DELAYED_GCODE ID=_DELAY_PSU_OFF DURATION=20
    {% endif %}
  {% endif %}
# 2h timeout
timeout: 7200


#####################################################################
#  Safety Relay extruder
#####################################################################
## Use a pin to switch on a relay for the Extruder heater
## if klipper is active
##
## XYE board, UPWR_DET_PIN Connector
# [output_pin extruder_relay]
# ## negativ logic
# pin: !P1.0
# pwm: false
# shutdown_value: 0
# value: 1

#####################################################################
#  Safety Relay heater_bed
#####################################################################
## Use a pin to switch on a relay for the  heater_bed
## if klipper is active
##
## Z board, UPWR_DET_PIN Connector
# [output_pin heater_bed_relay]
# ## negativ logic
# pin: !z:P1.0
# pwm: false
# shutdown_value: 0
# value: 1

#####################################################################
# 	Macro
#####################################################################
# switch on moonraker bed relay at klipper start
[delayed_gcode _INIT_MOONRAKER_BED]
initial_duration: 1
gcode:
  # will be ignored by moonraker if no power device called bed is defined
  {action_call_remote_method("set_device_power",
                             device="Bed",
                             state="on")}
                             
[gcode_macro _PSU_OFF]
description: Helper: Power down 24V PSU
gcode:
  # will be ignored by moonraker if no power device called psu is defined
  {action_respond_info("POWER: 24V PS power off")}
  {action_call_remote_method("set_device_power",
                             device="PSU",
                             state="off")}
                             
[delayed_gcode _DELAY_PSU_OFF]
gcode:
  {% if printer.idle_timeout.state != "Printing" %}
    _PSU_OFF
  {% endif %}

[gcode_macro _BED_OFF]
description: Helper: Power off BED power
gcode:
  {%if printer['output_pin heater_bed_relay'].value == 1 %}  
    {action_respond_info("POWER: heater_bed power off")}
    SET_PIN PIN=heater_bed_relay VALUE=0
  {% endif %}
  {action_call_remote_method("set_device_power",
                             device="Bed",
                             state="off")}
                                                       
[gcode_macro _BED_ON]
description: Helper: Power on BED power
gcode:
  {%if printer['output_pin heater_bed_relay'].value == 0 %}
    {action_respond_info("POWER: heater_bed power on")}
    SET_PIN PIN=heater_bed_relay VALUE=1
  {% endif %}
  {action_call_remote_method("set_device_power",
                             device="Bed",
                             state="on")}
                             
[gcode_macro _EXTRUDER_OFF]
description: Helper: Power off Extruder power
gcode:
  {%if printer['output_pin extruder_relay'].value == 1 %}
    {action_respond_info("POWER: extruder power off")}
    SET_PIN PIN=extruder_relay VALUE=0
  {% endif %}
                             
[gcode_macro _EXTRUDER_ON]
description: Helper: Power on Extruder power
gcode:
  {%if printer['output_pin extruder_relay'].value == 0 %}
    {action_respond_info("POWER: extruder power on")}
    SET_PIN PIN=extruder_relay VALUE=1
  {% endif %}
  
[gcode_macro _HEATER_ON]
description: Helper: Power on BED and Ectruder power 
gcode:
  _BED_ON
  _EXTRUDER_ON
            
[delayed_gcode _DELAY_HEATER_OFF]
gcode:
  {% if printer.idle_timeout.state != "Printing" %}
    _BED_OFF
    _EXTRUDER_OFF
  {% endif %}

#####################################################################
# 	LCD Menu & Macro to shutdown the PI
#####################################################################
# [gcode_macro _SHUTDOWN_PI]
# description: Helper: Power down the rPi
# gcode:
#   {action_call_remote_method("shutdown_machine")}

# [gcode_macro PRINTER_OFF]
# description: Park head and Power down the rPi
# gcode:
#   ##### Get user defines #####
#   {% set park_pos = printer['gcode_macro _USER_VARIABLE'].park_bed %}
#   ##### end of definitions #####
#   _CG28 ; home if not already homed
#   G90   ; absolute positioning
#   G0 X{park_pos[0]} Y{park_pos[1]} Z{park_pos[2]} F18000
#   M117 PI Off in 5 sec
#   G4 P5000
#   M400
#   _SHUTDOWN_PI
  
# ## Power Off LCD Menu Item
# [menu __main __power_off]
# type: command
# enable: {not printer.idle_timeout.state == "Printing"}
# name: Power Off
# index: 0
# gcode:
#     {menu.exit()}
#     PRINTER_OFF          
#+END_SRC
* Config Check
Checks that user vars are defined
#+BEGIN_SRC conf
[delayed_gcode _CHECK_CONFIG]
initial_duration: 0.1
gcode:
  ## exexcute _USER_VARIABLE once at startup to do the needed calcs
  {% if printer['gcode_macro _USER_VARIABLE'] is not defined %}
    { action_respond_info(
      "CONFIG: ERROR\n"
      "_USER_VARIABLE macro missing\n"
      "This holds common variables for your printer and must be defined") }
  {% else %}
    _USER_VARIABLE
    _CHECK_CONSITENT
  {% endif %}

[gcode_macro _CHECK_CONSITENT]
description: Helper: Check that some criterias are meet in the printer.cfg
gcode:
  ## check that a MagProbe is defined if z_calibrate is defined
  {% if printer['gcode_macro _USER_VARIABLE'].auto_z_offset|lower == 'z_calib' and
    printer['gcode_macro _USER_VARIABLE'].mag_probe|lower == 'false' %}
    {action_respond_info(
                         "CONFIG: ERROR\n"
                         "[z_calibration] defined but no MagProbe\n")}
  {% endif %}
  ## check if save_variables are defined
  {% if 'save_variables' not in printer %}
    {action_respond_info(
                         "CONFIG: ERROR\n"
                         "[save_variables] missing\n"
                         "This is needed to store variables to a file")}
  {% endif %}
  ## check if virtual_sdcard is defined
  {% if 'virtual_sdcard' not in printer %}
    {action_respond_info(
                         "CONFIG: ERROR\n"
                         "[virtual_sdcard] missing\n"
                         "The printer.cfg is designed to be used with Mainsail, therefore this definition is essential")}
  {% endif %}
#+END_SRC
* User Variables

#+BEGIN_SRC conf
[gcode_macro _USER_VARIABLE]
description: Helper: Contains User defined printer variables
##### enables for additional hardware #####
variable_neo_display: 'false'         ; true is display with neopixel in cfg
variable_chamber: 'none'              ; none/fan/sensor depending on cfg
variable_caselight: 'true'           ; true if caselight is found in cfg
variable_filter: 'false'              ; true if filter is found in cfg
variable_runout: 'none'               ; none/file/motion/switch depending on cfg
variable_relay: 'false'               ; true if safety relais are found in cfg
variable_auto_z_offset: 'none'        ; none/flexplate/z_calib depends what is found in cfg
variable_mag_probe: 'false'           ; true is a mag probe is found in cfg
##### Homing and general movement #####
variable_z_endstop: [0,0]             ; z Endstop position
variable_z_endstop_hop: 0             ; z hop for relative moves e.g. homimg
variable_center: [0,0,0]              ; center off bed
variable_z_hop: 0                     ; z_hop depending on mag_probe or endstop
variable_z_home_current: 0            ; reduced homing curent for z
variable_home_accel: 0                ; reduced ACCEL for homing
##### Mag Probe #####
variable_probe_dock: [0,0,0]          ; toolhead position before docking probe
variable_probe_undock: [0,0,0]        ; toolhead position after docking probe
variable_probe_travel_speed: 0        ; dock moves travel speed
variable_probe_dock_speed: 0          ; dock speed for attach/dock
##### Park Position #####
variable_park_bed: [0,0,0]            ; different park position
variable_park_frontlow: [0,0,0]       ; different park position
variable_park_front: [0,0,0]          ; different park position
variable_park_center: [0,0,0]         ; different park position
variable_park_rear: [0,0,0]           ; different park position
#### Filament #####
variable_extruder_min_add: 0          ; Temperature add to min Extruder temp
variable_load_distance : 0            ; load distance while load filament
variable_load_extrude : 0             ; extrude distance while load filament
variable_unload_distance : 0          ; unload distance while unload filament
variable_retreact_end: 0              ; retract distance at PRINT_END or CANCEL_PRINT
variable_retract_pause: 0             ; retract/extrude distance while PAUSE or RESUME
variable_retract_cancel: 0            ; difference between END and PAUSE retraction
##### Purge & Brush #####
variable_purge: [0,0,0]               ; purge bucket location
variable_wipe_start: [0,0,0]          ; start pos of wipe move
variable_wipe_end: [0,0,0]            ; end pos of wipe move
variable_wipe_offset: 0               ; distance for single wipe move
variable_wipe_cnt: 0                  ; number of full wipes
##### PRINT_START/STOP #####
variable_print_start_bed_up:  0       ; bed temp raise for faster heat soak
variable_print_start_ival: 0          ; wait time per call in sec
variable_print_start_extruder_time: 0 ; time in minutes before soak end to start extruder heating 
variable_print_start_bed_time: 0      ; time in minutes before soak end to set bed target temp
variable_print_start_prime_mult: 0    ; multiplier for prime line hight 
variable_print_end_unload_sd: 'false' ; unload sd file at PRINT_END or CANCEL_PRINT 
##### Prime Line #####
variable_prime_start_xy: [0,0]        ; xy start coordinates of prime line/ball
variable_prime_end_xy: [0,0]          ; xy end coordinates of prime ball
variable_prime_extrusion_amount: 0    ; Prime Ball Extrusion Amount
variable_prime_dir: 'None'            ; direction of prime line (X+, X-, Y+, Y-)
variable_prime_z: 0                   ; z hight for prime line
variable_prime_dist: 0                ; distance between line, move will allways positive
variable_prime_lenght: 0              ; length of prime line
variable_prime_seg: 0                 ; segments in that the prime line is splitted
variable_prime_extrude_per_seg: 0     ; amount of filament extruded per segment
##### Respond defaults #####
variable_respond_set_z_current: 0     ; default of RESPOND if not set in the call
variable_respond_set_acc: 0           ; default of RESPOND if not set in the call
variable_respond_probe_action: 0      ; default of RESPOND if not set in the call
##### Peripheral #####
variable_filter_on: 0                 ; filter on value
variable_filter_use_time: 0           ; Nevermore change warning limit 
variable_vent_on: 0                   ; chamber fan on temperature                        
variable_caselight_on: 0              ; caselight on value
variable_fan_run_after_print: 0       ; time in min to run filter and chamber exhaust after print finsih 
gcode:
  ###################################################################
  ##                     start of user defines                     ## 
  ## this needs to be changed for your printer                     ##
  ###################################################################
  #{% set user_z_endstop = [232.0,353.0] %}     ; z Endstop position insight right profil
  {% set user_z_endstop = [98.0,308.0] %}     ; z Endstop position insight left profil
  {% set user_z_endstop_hop = 20 %}           ; z hop for moves e.g homimg
  {% set user_z_home_current = 0.3 %}          ; reduced homing curent for z
  {% set user_home_accel = 1200 %}             ; reduced ACCEL for homing
  {% set user_bed_y_offset = 5 %}              ; Endstop offset to bed max y
  ##### Mag Probe #####
  {% set user_probe_dock_pos = [43,308,0] %}  ; position of the dock 
  {% set user_probe_delta_x = 30 %}            ; x offset for position before dock
  {% set user_probe_delta_y = -20 %}           ; y offset to move probe out of dock
  {% set user_probe_delta_z = 0 %}             ; z offset to move probe out of dock
  {% set user_z_probe_hop = 20 %}             ; z minimum heigh to avoid crash
  {% set user_probe_travel_speed = 200 %}      ; dock moves travel speed
  {% set user_probe_dock_speed = 100 %}        ; dock speed for attach/dock
  ##### Park Position #####
  {% set user_park_xy_delta = 25 %}            ; distance for x or y from the edge
  {% set user_park_z_max_delta = 100 %}         ; insure to do not hit cam in front
  {% set user_park_z_min = 30 %}               ; minimal z from bed
  ##### Filament #####
  {% set user_extruder_min_add = 50 %}         ; Temperature add to min Extruder temp
  {% set user_load_distance = 90 %}            ; load distance while load filament
  {% set user_load_extrude = 50 %}             ; extrude distance while load filament
  {% set user_unload_distance = 75 %}          ; unload distance while unload filament
  {% set user_retreact_end = 2 %}              ; retract distance at PRINT_END or CANCEL_PRINT
  {% set user_retract_pause = 1 %}             ; retract/extrude distance while PAUSE or RESUME
  ##### Purge & Brush #####
  {% set user_brush_pos = 'right' %}            ; left/right profile used
  #{% set user__brush_x_middle: 100 %}         ; mid point of brush at left profile
  {% set user_brush_x_middle = 225 %}          ; mid point of brush at right profil
  {% set user_brush_x_width = 50 %}            ; width of brush
  {% set user_brush_y_start = 307 %}           ; start point at y
  {% set user_wipe_z = 6.0 %}                  ; z for wipe moves
  {% set user_wipe_cnt = 3 %}                  ; number of full wipes
  {% set user_z_purge = 2.5 %}                 ; z above purge bucket
  ##### PRINT_START/STOP #####
  {% set user_print_start_bed_up = 10 %}       ; bed temp raise for faster heat soak
  {% set user_print_start_ival = 1 %}          ; wait time per call in sec
  {% set user_print_start_extruder_time = 3 %} ; time in minutes before soak end to start extruder heating 
  {% set user_print_start_bed_time = 3 %}      ; time in minutes before soak end to set bed target temp
  {% set user_print_start_prime_mult = 2 %}    ; multiplier for prime line hight 
  {% set user_print_end_unload_sd = 'true' %} ; unload sd file at PRINT_END or CANCEL_PRINT 
  ##### Prime Line ##### - Replaced by prime ball
  {% set user_prime_start_xy = [55,3] %}       ; x&y start coordinates of prime line/ball
  {% set user_prime_end_xy = [75,3] %}         ; x&y end coordinates of prime ball
  {% set user_prime_extrusion_amount = 40 %}   ; extrusion amount for prime ball
  {% set user_prime_z = 0.85 %}                ; z hight for prime line
  {% set user_prime_dir = 'X+' %}              ; direction of prime line (X+, X-, Y+, Y-)
  {% set user_prime_dist = 0.4 %}              ; distance between line, move will allways positive
  {% set user_prime_lenght = 220 %}            ; length of prime line
  {% set user_prime_seg = 11 %}                ; segments in that the prime line is splitted
  {% set user_prime_extrude_per_seg = 2 %}     ; amount of filament extruded per segment
  ##### Respond defaults #####
  {% set user_respond_set_z_current = 0 %}     ; default of RESPOND if not set in the call
  {% set user_respond_set_acc = 0 %}           ; default of RESPOND if not set in the call
  {% set user_respond_probe_action = 1 %}      ; default of RESPOND if not set in the call
  ##### Peripheral #####
  {% set user_filter_on = 0.5 %}               ; filter on value
  {% set user_filter_use_time = 80 %}          ; Nevermore change warning limit 
  {% set user_vent_on = 15 %}                  ; chamber fan on temperature                        
  {% set user_caselight_on = 0.4 %}            ; caselight on value
  {% set user_fan_run_after_print = 30 %}      ; time in min to run filter and chamber exhaust after print finsih 
  ###################################################################
  ##                      end of user defines                      ## 
  ###################################################################
  ##### get printer limits #####
  {% set min_x = printer.toolhead.axis_minimum.x|float %}
  {% set min_y = printer.toolhead.axis_minimum.y|float %}
  {% set max_x = printer.toolhead.axis_maximum.x|float %}
  {% set max_y = printer.toolhead.axis_maximum.y|float %}
  {% set max_z = printer.toolhead.axis_maximum.z|float %}
  ##### detect additional hardware #####
  {% if 'neopixel neo_display' in printer.configfile.settings %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=neo_display VALUE='"true"'
  {% endif %}
  {% if 'temperature_sensor chamber' in printer.configfile.settings %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=chamber VALUE='"sensor"'
  {% elif 'temperature_fan chamber' in printer.configfile.settings %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=chamber VALUE='"fan"'
  {% endif %}
  {% if 'output_pin caselight' in printer.configfile.settings %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=caselight VALUE='"true"'
  {% endif %}
  {% if 'fan_generic filter' in printer.configfile.settings %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=filter VALUE='"true"'
  {% endif %}
  {% if 'filament_switch_sensor runout' in printer.configfile.settings %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=runout VALUE='"switch"'
  {% elif 'filament_motion_sensor runout' in printer.configfile.settings %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=runout VALUE='"motion"'
  {% elif 'virtual_sdcard' in printer and filament_loaded in printer.save_variables.variables %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=runout VALUE='"file"'
  {% endif %}
  {% if 'output_pin extruder_relay' in printer.configfile.settings and
  'output_pin heater_bed_relay'  in printer.configfile.settings %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=relay VALUE='"true"'
  {% endif %}
  {% if 'z_calibration' in  printer %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=auto_z_offset VALUE='"z_calib"'
  {% elif printer['gcode_macro _SET_PLATE_OFFSET'] is defined %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=auto_z_offset VALUE='"flexplate"'
  {% endif %}
  {% if printer['gcode_macro _MAG_PROBE'] is defined or 'dockable_probe' in printer %}
   {% set mag_probe = 'true' %}
    SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=mag_probe VALUE='"true"'
  {% endif %}
  ##### calc needed values out of the user definition #####
  {% if mag_probe|lower == 'true' %}
    {% if user_z_probe_hop > user_z_endstop_hop %}
      {%set calc_z_hop = user_z_probe_hop %} 
    {% else %}
      {%set calc_z_hop = user_z_endstop_hop %} 
    {% endif %}
  {% else %}
    {% set calc_z_hop = user_z_endstop_hop %} 
  {% endif %}
  {% set calc_brush_start_x = user_brush_x_middle|float - user_brush_x_width|float / 2 %}
  {% set calc_brush_end_x = user_brush_x_middle|float + user_brush_x_width|float / 2 %}
  {% if user_brush_pos|lower == 'left' %}
    #purge bucket is left of brush on the left bed profile
    {% set calc_purge_x = (min_x + calc_brush_start_x) / 2 %}
    {% set calc_wipe_start_x = calc_brush_start_x %}
    {% set calc_wipe_end_x = calc_brush_end_x %}
  {% else %}
    #purge bucket is right of brush on the right bed profile
    {% set calc_purge_x = (max_x - (max_x - calc_brush_end_x) / 2)  %}
    {% set calc_wipe_start_x = calc_brush_end_x %}
    {% set calc_wipe_end_x = calc_brush_start_x %}
  {% endif %}
  {% set calc_wipe_start_y = user_brush_y_start|float %}
  {% set calc_wipe_end_y = max_y %}
  {% set calc_wipe_delta = calc_wipe_end_y - calc_wipe_start_y %}
  {% set calc_purge_y = max_y - (calc_wipe_delta / 2)  %}
  {% set calc_wipe_offset = calc_wipe_delta / user_wipe_cnt|float %}
  {% set calc_center_x = max_x / 2 %}
  {% set calc_center_y = (max_y - user_bed_y_offset) / 2 %}
  {% set calc_center_z = max_z / 2 %}
  {% set calc_retract_cancel = user_retreact_end - user_retract_pause %}
  {% set calc_probe_dock_x = user_probe_dock_pos[0] %}
  {% set calc_probe_dock_y = user_probe_dock_pos[1] + user_probe_delta_y %}
  {% set calc_probe_dock_z = user_probe_dock_pos[2] + user_probe_delta_z %}
  {% set calc_probe_undock_x = user_probe_dock_pos[0] + user_probe_delta_x %}
  {% set calc_probe_undock_y = user_probe_dock_pos[1] %}
  {% set calc_probe_undock_z = user_probe_dock_pos[2] %}
  {% set calc_park_min_x = min_x + user_park_xy_delta %}
  {% set calc_park_min_y = min_y + user_park_xy_delta %}
  {% set calc_park_max_x = max_x - user_park_xy_delta %}
  {% set calc_park_max_y = max_y - user_park_xy_delta %}
  {% set calc_park_max_z = max_z - user_park_z_max_delta %}
  ##### define arrays #####
  {% set purge_array = [calc_purge_x|float,calc_purge_y|float,user_z_purge|float] %}
  {% set wipe_start_array = [calc_wipe_start_x|float,calc_wipe_start_y|float,user_wipe_z|float] %}
  {% set wipe_end_array = [calc_wipe_end_x|float,calc_wipe_end_y|float,user_wipe_z|float] %}
  {% set center_array = [calc_center_x|float,calc_center_y|float,calc_center_z|float] %}
  {% set probe_dock_array = [calc_probe_dock_x|float,calc_probe_dock_y|float,calc_probe_dock_z|float] %}
  {% set probe_undock_array = [calc_probe_undock_x|float,calc_probe_undock_y|float,calc_probe_undock_z|float] %}
  {% set park_bed_array = [calc_center_x|float,calc_center_y|float,user_park_z_min|float] %}
  {% set park_frontlow_array = [calc_center_x|float,calc_park_min_y|float,user_park_z_min|float] %}
  {% set park_front_array = [calc_center_x|float,calc_park_min_y|float,calc_park_max_z|float] %}
  {% set park_center_array = [calc_center_x|float,calc_center_y|float,calc_center_z|float] %}
  {% set park_rear_array = [calc_park_min_x|float,calc_park_max_y|float,calc_park_max_z|float] %}
  ##### store results in variables #####
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=z_endstop VALUE="{user_z_endstop}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=z_endstop_hop VALUE={user_z_endstop_hop}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=center VALUE="{center_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=z_hop VALUE={calc_z_hop}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=z_home_current VALUE={user_z_home_current}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=home_accel VALUE={user_home_accel}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=probe_dock VALUE="{probe_dock_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=probe_undock VALUE="{probe_undock_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=probe_travel_speed VALUE={user_probe_travel_speed}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=probe_dock_speed VALUE={user_probe_dock_speed}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=park_bed VALUE="{park_bed_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=park_frontlow VALUE="{park_frontlow_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=park_front VALUE="{park_front_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=park_center VALUE="{park_center_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=park_rear VALUE="{park_rear_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=extruder_min_add VALUE={user_extruder_min_add}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=load_distance VALUE={user_load_distance}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=load_extrude VALUE={user_load_extrude}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=unload_distance VALUE={user_unload_distance}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=retreact_end VALUE={user_retreact_end}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=retract_pause VALUE={user_retract_pause}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=retract_cancel VALUE={calc_retract_cancel}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=purge VALUE="{purge_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=wipe_start VALUE="{wipe_start_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=wipe_end VALUE="{wipe_end_array}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=wipe_offset VALUE={calc_wipe_offset}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=wipe_cnt VALUE={user_wipe_cnt}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=print_start_bed_up VALUE={user_print_start_bed_up}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=print_start_ival VALUE={user_print_start_ival}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=print_start_extruder_time VALUE={user_print_start_extruder_time}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=print_start_bed_time VALUE={user_print_start_bed_time}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=print_start_prime_mult VALUE={user_print_start_prime_mult}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=print_end_unload_sd VALUE='"{user_print_end_unload_sd}"'
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=prime_start_xy VALUE="{user_prime_start_xy}"
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=prime_dir VALUE='"{user_prime_dir}"'
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=prime_z VALUE={user_prime_z}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=prime_dist VALUE={user_prime_dist}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=prime_lenght VALUE={user_prime_lenght}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=prime_seg VALUE={user_prime_seg}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=prime_extrude_per_seg VALUE={user_prime_extrude_per_seg}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=respond_set_z_current VALUE={user_respond_set_z_current}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=respond_set_acc VALUE={user_respond_set_acc}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=respond_probe_action VALUE={user_respond_probe_action}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=filter_on VALUE={user_filter_on}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=filter_use_time VALUE={user_filter_use_time}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=vent_on VALUE={user_vent_on}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=caselight_on VALUE={user_caselight_on}
  SET_GCODE_VARIABLE MACRO=_USER_VARIABLE VARIABLE=fan_run_after_print VALUE={user_fan_run_after_print}
#+END_SRC
* Moonraker Config
** Server
#+BEGIN_SRC conf :tangle moonraker.conf
[server]
host: 0.0.0.0
port: 7125
klippy_uds_address: /tmp/klippy_uds

#   The maximum size allowed for a file upload.  Default is 1024 MiB.
max_upload_size: 1024
#   When set to True Moonraker will log in verbose mode.  During this stage
#   of development the default is True.  In the future this will change.
enable_debug_logging: False
#   The path to the folder that stores Moonraker's lmdb database files.
#   It is NOT recommended to place this file in a location that is served by
#   Moonraker (such as the "config_path" or the location where gcode
#   files are stored).  If the folder does not exist an attempt will be made
#   to create it.  The default is ~/.moonraker_database.


[database]
database_path: ~/.moonraker_database


[file_manager]
config_path: /home/pi/klipper_config
#   An optional path to a directory where log files are located.  Users may
#   configure various applications to store logs here and Moonraker will serve
#   them at "/server/files/logs/*".  The default is no log paths.
log_path: /home/pi/klipper_logs
enable_object_processing: True

[authorization]
cors_domains:
  ,*.lan
  ,*.local
  ,*://my.mainsail.xyz
  ,*://app.fluid.xys
  ,*:7136
trusted_clients:
  127.0.0.1
  192.168.1.10
  192.168.1.52
  192.168.1.11

[octoprint_compat]

[history]
#+END_SRC

** Update Manager
#+BEGIN_SRC conf :tangle moonraker.conf
[update_manager]
enable_repo_debug: False
enable_auto_refresh: True

[update_manager fluidd]
type: web
repo: cadriel/fluidd
path: ~/fluidd

[update_manager client KlipperScreen]
type: git_repo
path: /home/pi/KlipperScreen
env: /home/pi/.KlipperScreen-env/bin/python
origin: https://github.com/jordanruthe/KlipperScreen.git
requirements: scripts/KlipperScreen-requirements.txt
venv_args: -p python3
install_script: scripts/KlipperScreen-install.sh

[update_manager client z_calibration]
type: git_repo
path: /home/pi/klipper_z_calibration
origin: https://github.com/protoloft/klipper_z_calibration.git
install_script: install.sh


[update_manager client kiauh]
type: git_repo
path: /home/pi/kiauh
origin: https://github.com/th33xitus/kiauh.git

[update_manager mainsail]
type: web
channel: stable
repo: mainsail-crew/mainsail
path: ~/mainsail
#+END_SRC
** Power
#+BEGIN_SRC conf :tangle moonraker.conf
[power Board]
type: gpio
pin: gpio17
initial_state: on
#off_when_shutdown: True
locked_while_printing: True
restart_klipper_when_powered: True
restart_delay: 2

[power PSU]
type: gpio
pin: gpio27
initial_state: on
#off_when_shutdown: True
locked_while_printing: True
restart_klipper_when_powered: True
restart_delay: 2

[power Bed]
type: gpio
pin: gpio22
initial_state: on
#off_when_shutdown: True
locked_while_printing: True
restart_klipper_when_powered: False

[power Fans]
type: gpio
pin: gpio23
initial_state: on
#off_when_shutdown: True
locked_while_printing: False
restart_klipper_when_powered: False

[power Lights]
type: gpio
pin: !gpio24
initial_state: off
#off_when_shutdown: True
locked_while_printing: False
restart_klipper_when_powered: False

[power DFU]
type: gpio
pin: !gpio25
initial_state: off
#off_when_shutdown: True
locked_while_printing: True
restart_klipper_when_powered: False

[power Aux-1]
type: gpio
pin: gpio5
initial_state: off


[power Aux-2]
type: gpio
pin: gpio6
initial_state: off

#+END_SRC
